<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ACM实验室关于2021级新生课程开设的通知</title>
      <link href="/2021/09/14/2021-Newer-Training/"/>
      <url>/2021/09/14/2021-Newer-Training/</url>
      
        <content type="html"><![CDATA[<p>为了拓展21级新同学的思维方式，提升21级新同学的编程兴趣，筑牢21级新同学的编程基础，西南大学ACM实验室在21级课程内容的基础上，开设针对21级新同学的计算机编程拓展课程，这里是本次课程的开设通知。</p><span id="more"></span><h2 id="课程信息"><a href="#课程信息" class="headerlink" title="课程信息"></a>课程信息</h2><ol><li><p>开课对象</p><p> 西南大学2021级全体新生，不限学院，不限专业，不限校区。</p><p> <strong>本课程尤其针对零基础的新生，快速上手计算机程序设计。</strong></p></li><li><p>开课方式</p><p> 线上线下同步开课。</p></li><li><p>开课地点</p><p> 线下： 西南大学荣昌校区，具体地点待定。<br> 线上： 预计使用腾讯会议或钉钉会议。<br> 回放： bilibili-西南大学商贸学院ACM。</p></li><li><p>开课时间</p><p> 从2021年10月9日起，每个周末开两次课，共五星期，十次课，一次课四十五分钟。</p></li><li><p>开课内容</p><p> 见下文。</p></li><li><p>报名方式</p><p> 点击 <a href="https://docs.qq.com/form/page/DV0lkV0VKVUJwQXBO">报名链接</a> 报名。</p><p> <strong>报名将于2021年10月1日 0:00截止</strong></p></li></ol><h2 id="课程内容"><a href="#课程内容" class="headerlink" title="课程内容"></a>课程内容</h2><ol><li><p>环境的安装与配置</p><p> 本节将安装GNU-GCC编译器环境，讲解MSVC，GCC，LLVM等编译器的区别，并配置好VSCode作为开发工具，同时分析CLion，XCode，VS等IDE的特征，并讲解VSCode，Nodepad++，Vim等轻量编辑器的使用场景。</p></li><li><p>Markdown，Git与文档</p><p> 本节将讲述计算机行业常用的写作语言Markdown和相关应用，指引同学们使用VSCode与Typora进行Markdown写作，同时讲解版本控制系统Git的基础用法，带领同学们体验项目协作的流程。</p></li><li><p>模拟（1）</p><p> 本节将从最近大火的亚文化科技产品《Genshin Impact(R) CN》入手，带领同学们熟悉C/C++这门编程语言，并使用C/C++解决一些常见问题。此节课侧重于讲解C/C++编程语言。</p></li><li><p>模拟（2）</p><p> 本节将从最近大火的亚文化科技产品《Genshin Impact(R) CN》入手，带领同学们熟悉C/C++这门编程语言，并使用C/C++解决一些常见问题。此节课侧重于讲解实际问题的解决（如：银行家算法）。</p></li><li><p>面向对象（1）</p><p> 本节课将从生活实际出发，带领同学们领会面向对象的编程思想，并了解C/C++与Java/.Net中是如何应用面向对象的四相关解决对应需求的。此节课侧重于讲解类、字段与继承。</p></li><li><p>面向对象（2）</p><p> 本节课将从生活实际出发，带领同学们领会面向对象的编程思想，并了解C/C++与Java/.Net中是如何应用面向对象的四相关解决对应需求的。此节课侧重于讲解多态与接口。</p></li><li><p>数论与数学</p><p> 本节课将从最近大火的亚文化科技产品《Genshin Impact(R) CN》入手，讲解计算机中常见的数学与数论问题。</p></li><li><p>遍历与搜索</p><p> 本节课将从最近大火的亚文化科技产品《Genshin Impact(R) CN》入手，带领同学们了解并尝试遍历思想，了解深度优先搜索、广度优先搜索的应用。</p></li><li><p>服务器操作</p><p> 本节课将带领同学们部署一个自己的网站，同时从<code>WordPress</code>，<code>NextCloud</code>，<code>Gitea</code>等优秀Docker项目中选取一个作为实操演练。</p></li><li><p>项目实操</p><p>本节课将从五子棋、聊天室、弹幕姬等项目预案中选取一个，并带领同学们实现其功能。</p></li></ol><h2 id="课程安排"><a href="#课程安排" class="headerlink" title="课程安排"></a>课程安排</h2><ol><li><p>小组合作</p><p> 所有参加课程的同学均会被组合为三人单位的小组中，每组将会有一个负责人。</p></li></ol><h2 id="课程负责人"><a href="#课程负责人" class="headerlink" title="课程负责人"></a>课程负责人</h2><ul><li><p>指导老师： </p><p>西南大学商贸学院 杜治国 副教授</p></li><li><p>主讲：</p><p> 2019级计算机科学与技术专业 陈羿羽</p></li><li><p>助教：</p><p>  2020级信息管理与信息系统专业 黄梓豪<br>  2020级信息管理与信息系统专业 蒲美琴</p></li><li><p>答疑：</p><p>  2019级计算机科学与技术专业 尹志欣<br>  2019级计算机科学与技术专业 吴银杰</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Announcement </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Announcement </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动驾驶技术路线探究 - 第一阶段报告</title>
      <link href="/2021/08/05/Tesla-Research-Stage-1/"/>
      <url>/2021/08/05/Tesla-Research-Stage-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>作者SunistC： 由于公司保密协议要求，本报告大部分内容均已删减，并且后续报告不再发表。</p></blockquote><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><h3 id="1-Architectures-of-Autonomous-Vehicle"><a href="#1-Architectures-of-Autonomous-Vehicle" class="headerlink" title="1. Architectures of Autonomous Vehicle"></a>1. Architectures of Autonomous Vehicle</h3><div align="center"><img src="https://z3.ax1x.com/2021/08/06/fnFM8A.png" width="500px"/></br>Figure-1: 自动驾驶系统体系结构的高级分类<sup id="fnref:10" class="footnote-ref"><a href="#fn:10" rel="footnote"><span class="hint--top hint--rounded" aria-label="Yurtsever E, Lambert J, Carballo A, et al. A survey of autonomous driving: Common practices and emerging technologies[J]. IEEE access, 2020, 8: 58443-58469.">[10]</span></a></sup></div><p>自动驾驶汽车的感知系统一般由<code>相机</code>，<code>激光雷达</code>，<code>声波雷达</code>，<code>定位设备</code>等四类设备<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Zhou Z, Akhtar Z, Man K L, et al. A deep learning platooning-based video information-sharing Internet of Things framework for autonomous driving systems[J]. International Journal of Distributed Sensor Networks, 2019, 15(11): 1550147719883133.">[3]</span></a></sup>组成。</p><div align="center"><img src="https://z3.ax1x.com/2021/08/05/fVWGA1.png" width="700px"/></br>Figure-2: 自动驾驶汽车的结构</div><p>其中的常见设备感知范围与视野资料如下：</p><div align="center"><img src="https://z3.ax1x.com/2021/08/05/fVju34.png" width="700px"/></br>Figure-3: 常见感知设备感知参数<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="Zhou Z, Akhtar Z, Man K L, et al. A deep learning platooning-based video information-sharing Internet of Things framework for autonomous driving systems[J]. International Journal of Distributed Sensor Networks, 2019, 15(11): 1550147719883133.">[3]</span></a></sup></div><p>其感知距离多在$5 \sim 100$米，感知视野多在$90^\circ \sim 120^\circ$。同时，下表类比了各类设备的异同：</p><div align="center"><img src="https://z3.ax1x.com/2021/08/06/fneEDI.png"/></br>Table-1: 各类传感器的类比<sup id="fnref:16" class="footnote-ref"><a href="#fn:16" rel="footnote"><span class="hint--top hint--rounded" aria-label="T. B. Lee. How 10 Leading Companies Are Trying To Make Powerful, Low-Cost Lidar. Accessed: May 19, 2019. [Online]. Available: https://arstechnica.com/cars/2019/02/the-ars-technica-guide-to-the-lidar-industry">[16]</span></a></sup></div><ul><li><p>安全<br>自动驾驶汽车在近期的测试中出现了大量的事故，谷歌的汽车在行驶中因为无法辨别一辆公共汽车的速度，与其发生了碰撞<sup id="fnref:11" class="footnote-ref"><a href="#fn:11" rel="footnote"><span class="hint--top hint--rounded" aria-label="A. Davies. Google’s Self-Driving Car Caused Its First Crash. Accessed: Dec. 16, 2018. [Online]. Available: https://www.wired.com/2016/02/googles-self-driving-car-may-caused-first-crash">[11]</span></a></sup>，特斯拉的汽车将白色卡车识别为天空二发生碰撞<sup id="fnref:12" class="footnote-ref"><a href="#fn:12" rel="footnote"><span class="hint--top hint--rounded" aria-label="M. McFarland. Who’s Responsible When an Autonomous Car Crashes? Accessed: Jun. 4, 2019. [Online]. Available: https://money.cnn.com/2016/07/07/technology/tesla-liability-risk/index.html">[12]</span></a></sup>，百度的汽车在行驶过程中无法辨认障碍物而发生碰撞<sup id="fnref:14" class="footnote-ref"><a href="#fn:14" rel="footnote"><span class="hint--top hint--rounded" aria-label="一鹿有车. 干翻特斯拉？百度Apollo自动驾驶体验[Online]. 哔哩哔哩弹幕网, 2021, 4. Available: https://www.bilibili.com/video/BV1bK4y1P7Ba">[14]</span></a></sup>，这一系列事故使得公众与社会对自动驾驶汽车驾驶的安全性要求极高，尤其是在中国大陆，对自动驾驶汽车不安全的容忍度仅为其余主流国家的$50\%$<sup id="fnref:13" class="footnote-ref"><a href="#fn:13" rel="footnote"><span class="hint--top hint--rounded" aria-label="Deloitte. 2019 Deloitte Global Automotive Consumer Study— Advanced Vehicle Technologies and Multimodal Transportation, Global Focus Countries. Accessed: May 19, 2019. [Online]. Available: https://www2.deloitte.com/content/dam/Deloitte/us/Documents/manufacturing/us-global-automotive-consumer-study-2019.pdf">[13]</span></a></sup>。</p><div align="center"><img src="https://z3.ax1x.com/2021/08/06/fnp1Gq.png"/>Figure-4: 关于自动驾驶汽车安全性的市场调研</div><p>并且自动驾驶汽车所造成的事故在大多数情况下是可能致命的，所以自动驾驶系统需要设计较大的冗余度以降低灾难性故障，但同时这也对系统的调度难度与鲁棒性提出了新的挑战。</p></li></ul><h2 id="Tesla-Mode"><a href="#Tesla-Mode" class="headerlink" title="Tesla Mode"></a>Tesla Mode</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><h3 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h3><h3 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><ol><li>无法保证系统的安全性、可靠性，在应对光学干扰时基本无法完成工作<sup id="fnref:15" class="footnote-ref"><a href="#fn:15" rel="footnote"><span class="hint--top hint--rounded" aria-label="Arnold E, Al-Jarrah O Y, Dianati M, et al. A survey on 3d object detection methods for autonomous driving applications[J]. IEEE Transactions on Intelligent Transportation Systems, 2019, 20(10): 3782-3795.">[15]</span></a></sup>。</li><li>遇到问题唤醒驾驶员可能导致安全事故发生的几率增大<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><span class="hint--top hint--rounded" aria-label="Gold C, Körber M, Lechner D, et al. Taking over control from highly automated vehicles in complex traffic situations: the role of traffic density[J]. Human factors, 2016, 58(4): 642-652.">[9]</span></a></sup>。</li></ol><h3 id="Prospect"><a href="#Prospect" class="headerlink" title="Prospect"></a>Prospect</h3><h2 id="Huawei-Mode"><a href="#Huawei-Mode" class="headerlink" title="Huawei Mode"></a>Huawei Mode</h2><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><h3 id="Advantages-1"><a href="#Advantages-1" class="headerlink" title="Advantages"></a>Advantages</h3><h3 id="Disadvantages-1"><a href="#Disadvantages-1" class="headerlink" title="Disadvantages"></a>Disadvantages</h3><h3 id="Prospect-1"><a href="#Prospect-1" class="headerlink" title="Prospect"></a>Prospect</h3><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Oh C, Yoon J. Hardware acceleration technology for deep-learning in autonomous vehicles[C] 2019 IEEE International Conference on Big Data and Smart Computing (BigComp). IEEE, 2019: 1-3.<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>Welling E and Oppelt M. Convolutional neural networks in autonomous vehicle control systems, 2017<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>Zhou Z, Akhtar Z, Man K L, et al. A deep learning platooning-based video information-sharing Internet of Things framework for autonomous driving systems[J]. International Journal of Distributed Sensor Networks, 2019, 15(11): 1550147719883133.<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>尉志青, 马昊, 张奇勋, 等. 感知-通信-计算融合的智能车联网挑战与趋势[J]. 中兴通讯技术, 2020, 1.<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>王科俊, 赵彦东, 邢向磊. 深度学习在无人驾驶汽车领域应用的研究进展[J]. 智能系统学报, 2018, 13(1): 55-69.<a href="#fnref:5" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>小马智行PonyAI. 1小时实录：广州高峰期1小时全自动驾驶，无人类干预[Online]. 哔哩哔哩弹幕网, 2021, 3. Available: <a href="https://www.bilibili.com/video/BV19p4y1h7KP">https://www.bilibili.com/video/BV19p4y1h7KP</a><a href="#fnref:6" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>Endsley M R. Autonomous driving systems: A preliminary naturalistic study of the Tesla Model S[J]. Journal of Cognitive Engineering and Decision Making, 2017, 11(3): 225-238.<a href="#fnref:7" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>Yurtsever E, Lambert J, Carballo A, et al. A survey of autonomous driving: Common practices and emerging technologies[J]. IEEE access, 2020, 8: 58443-58469.<a href="#fnref:8" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>Gold C, Körber M, Lechner D, et al. Taking over control from highly automated vehicles in complex traffic situations: the role of traffic density[J]. Human factors, 2016, 58(4): 642-652.<a href="#fnref:9" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:10" class="footnote-text"><span>Yurtsever E, Lambert J, Carballo A, et al. A survey of autonomous driving: Common practices and emerging technologies[J]. IEEE access, 2020, 8: 58443-58469.<a href="#fnref:10" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:11" class="footnote-text"><span>A. Davies. Google’s Self-Driving Car Caused Its First Crash. Accessed: Dec. 16, 2018. [Online]. Available: <a href="https://www.wired.com/2016/02/googles-self-driving-car-may-caused-first-crash">https://www.wired.com/2016/02/googles-self-driving-car-may-caused-first-crash</a><a href="#fnref:11" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:12" class="footnote-text"><span>M. McFarland. Who’s Responsible When an Autonomous Car Crashes? Accessed: Jun. 4, 2019. [Online]. Available: <a href="https://money.cnn.com/2016/07/07/technology/tesla-liability-risk/index.html">https://money.cnn.com/2016/07/07/technology/tesla-liability-risk/index.html</a><a href="#fnref:12" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:13" class="footnote-text"><span>Deloitte. 2019 Deloitte Global Automotive Consumer Study— Advanced Vehicle Technologies and Multimodal Transportation, Global Focus Countries. Accessed: May 19, 2019. [Online]. Available: <a href="https://www2.deloitte.com/content/dam/Deloitte/us/Documents/manufacturing/us-global-automotive-consumer-study-2019.pdf">https://www2.deloitte.com/content/dam/Deloitte/us/Documents/manufacturing/us-global-automotive-consumer-study-2019.pdf</a><a href="#fnref:13" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:14" class="footnote-text"><span>一鹿有车. 干翻特斯拉？百度Apollo自动驾驶体验[Online]. 哔哩哔哩弹幕网, 2021, 4. Available: <a href="https://www.bilibili.com/video/BV1bK4y1P7Ba">https://www.bilibili.com/video/BV1bK4y1P7Ba</a><a href="#fnref:14" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:15" class="footnote-text"><span>Arnold E, Al-Jarrah O Y, Dianati M, et al. A survey on 3d object detection methods for autonomous driving applications[J]. IEEE Transactions on Intelligent Transportation Systems, 2019, 20(10): 3782-3795.<a href="#fnref:15" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:16" class="footnote-text"><span>T. B. Lee. How 10 Leading Companies Are Trying To Make Powerful, Low-Cost Lidar. Accessed: May 19, 2019. [Online]. Available: <a href="https://arstechnica.com/cars/2019/02/the-ars-technica-guide-to-the-lidar-industry">https://arstechnica.com/cars/2019/02/the-ars-technica-guide-to-the-lidar-industry</a><a href="#fnref:16" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:17" class="footnote-text"><span>Suhr J K, Jang J, Min D, et al. Sensor fusion-based low-cost vehicle localization system for complex urban environments[J]. IEEE Transactions on Intelligent Transportation Systems, 2016, 18(5): 1078-1086.<a href="#fnref:17" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:18" class="footnote-text"><span>Hata A, Wolf D. Road marking detection using LIDAR reflective intensity data and its application to vehicle localization[C] 17th International IEEE Conference on Intelligent Transportation Systems (ITSC). IEEE, 2014: 584-589.<a href="#fnref:18" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:19" class="footnote-text"><span>Gruyer D, Belaroussi R, Revilloud M. Accurate lateral positioning from map data and road marking detection[J]. Expert Systems with Applications, 2016, 43: 1-8.<a href="#fnref:19" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:20" class="footnote-text"><span>Qu X, Soheilian B, Paparoditis N. Vehicle localization using mono-camera and geo-referenced traffic signs[C] 2015 IEEE Intelligent Vehicles Symposium (IV). IEEE, 2015: 605-610.<a href="#fnref:20" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:21" class="footnote-text"><span>Ort T, Paull L, Rus D. Autonomous vehicle navigation in rural environments without detailed prior maps[C] 2018 IEEE international conference on robotics and automation (ICRA). IEEE, 2018: 2040-2047.<a href="#fnref:21" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:22" class="footnote-text"><span>Wolcott R W, Eustice R M. Visual localization within lidar maps for automated urban driving[C] 2014 IEEE/RSJ International Conference on Intelligent Robots and Systems. IEEE, 2014: 176-183.<a href="#fnref:22" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      <categories>
          
          <category> Report </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IoT </tag>
            
            <tag> Autonomous Vehicle </tag>
            
            <tag> Autonomous Driving </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写作指导</title>
      <link href="/2021/08/04/Guidance/"/>
      <url>/2021/08/04/Guidance/</url>
      
        <content type="html"><![CDATA[<p>这是blog.swu-acm.cn的发文指引，仅供西南大学ACM实验室内部成员使用</p><span id="more"></span><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>这是托管于GitHub Page的一个静态博客站点，使用Hexo驱动，Fluid主题美化，在撰写文章之前，需要进行以下准备工作：</p><ol><li>在本机安装node环境和相关依赖</li><li>fork本站点并在本地部署</li></ol><p>然后在发文时需要进行以下步骤：</p><ol><li>检查仓库版本</li><li>撰写文章并commit</li><li>发起pull request</li><li>等待合并</li></ol><h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a>Preparation</h2><h3 id="在本机安装node环境"><a href="#在本机安装node环境" class="headerlink" title="在本机安装node环境"></a>在本机安装<code>node</code>环境</h3><p>建议使用<code>nvm</code>对<code>node</code>环境进行管理，ACM实验室的镜像站镜像了一份<code>nvm</code>仓库。</p><blockquote><p><code>nvm</code> : Node Version Manager，是控制node版本的一个工具包</p></blockquote><ol><li><p>(仅支持Linux/Unix/macOS<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="Windows请直接到nvm-windows仓库下载安装包。">[1]</span></a></sup>)执行下面的安装语句<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="由于版本可能发生更迭，建议前往mirrors/nvm查看最新的安装语句。">[2]</span></a></sup>：</p><p> <strong><em>Curl</em></strong></p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl -o- https://gitea.swu-acm.cn/mirrors/nvm/raw/branch/master/install.sh | bash<br></code></pre></div></td></tr></table></figure><p> <strong><em>Wget</em></strong></p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">wget -q0- https://gitea.swu-acm.cn/mirrors/nvm/raw/branch/master/install.sh | bash<br></code></pre></div></td></tr></table></figure><p> 执行完成后，<code>nvm</code>就被安装在<code>~/.nvm</code>文件夹内了，需要将其添加到环境变量中，在<code>~/.bashrc</code>，<code>~/.zshrc</code>，<code>~/.profile</code>中任意一个文件添加如下内容<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="如果你使用的是bash，请在bashrc中添加，如果你使用的是zsh，请在zshrc中添加，其他shell请按照实际情况添加。">[3]</span></a></sup>：</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">export NVM_DIR=&quot;$([ -z &quot;$&#123;XDG_CONFIG_HOME-&#125;&quot; ] &amp;&amp; printf %s &quot;$&#123;HOME&#125;/.nvm&quot; || printf %s &quot;$&#123;XDG_CONFIG_HOME&#125;/nvm&quot;)&quot;<br>[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm<br></code></pre></div></td></tr></table></figure></li><li><p>使用<code>nvm</code>安装<code>node</code>：</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvm install $version<br></code></pre></div></td></tr></table></figure><p> <code>$version</code>是你要安装的<code>node</code>版本</p></li><li><p>使用<code>nvm</code>激活<code>node</code>环境</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">nvm use $version<br></code></pre></div></td></tr></table></figure><p> <code>$version</code>是你要使用的<code>node</code>版本</p></li></ol><p>现在就大功告成啦</p><h3 id="在本地部署Hexo站点"><a href="#在本地部署Hexo站点" class="headerlink" title="在本地部署Hexo站点"></a>在本地部署Hexo站点</h3><ol><li><p>首先从<a href="https://gitea.swu-acm.cn/SWU-ACM-Lab/original-swu-blog">original-swu-blog</a><sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><span class="hint--top hint--rounded" aria-label="只有ACM实验室的注册成员且被分配了权限，才能访问该仓库。">[4]</span></a></sup>仓库中fork到你个人的仓库，下面你个人的仓库地址将使用<code>$repo</code>来表示：</p><p> <strong><em>添加<a href="https://gitea.swu-acm.cn/SWU-ACM-Lab/original-swu-blog">original-swu-blog</a>仓库为<code>upstream</code></em></strong></p><p> 在<code>$repo</code>目录下执行下面的命令：</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git remote add upstream https://gitea.swu-acm.cn/SWU-ACM-Lab/original-swu-blog<br></code></pre></div></td></tr></table></figure><p> 这样你将可以同步<a href="https://gitea.swu-acm.cn/SWU-ACM-Lab/original-swu-blog">original-swu-blog</a>仓库的更改。</p></li><li><p>然后安装必须的依赖：</p><p> 在<code>$repo</code>目录下执行下面的命令：</p><p> <strong><em>hexo-cli</em></strong></p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install hexo-cli --save<br></code></pre></div></td></tr></table></figure><p> <strong><em>Fluid主题</em></strong></p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install hexo-theme-fluid --save<br></code></pre></div></td></tr></table></figure><p> <strong><em>其余依赖</em></strong></p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">yarn<br></code></pre></div></td></tr></table></figure></li><li><p>然后跑起来：</p><p> 在<code>$repo</code>目录下执行下面的命令：</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo server<br></code></pre></div></td></tr></table></figure><p> 本地站点会在<a href="http://localhost:4000">localhost:4000</a>进行服务，可以在浏览器访问看一下效果。</p></li></ol><h2 id="Writting"><a href="#Writting" class="headerlink" title="Writting"></a>Writting</h2><p>为了保证理解正确，建议阅读文章<a href="https://blog.csdn.net/SirM2z/article/details/50421800">GitHub从fork到pull request之基础流程</a>。</p><h3 id="检查远程仓库版本"><a href="#检查远程仓库版本" class="headerlink" title="检查远程仓库版本"></a>检查远程仓库版本</h3><p>在<code>$repo</code>目录下执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git fetch --dry-run # 检查原仓库是否有变化<br>git pull # 将原仓库的更改与本地同步<br></code></pre></div></td></tr></table></figure><h3 id="撰写文章"><a href="#撰写文章" class="headerlink" title="撰写文章"></a>撰写文章</h3><ol><li><p>生成文章</p><p> 在<code>$repo</code>目录下执行下面的命令：</p> <figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">hexo new post $postname<br></code></pre></div></td></tr></table></figure><p> <strong>注意</strong> <code>$postname</code>将作为文章的URL，请不要使用中文和其他特殊字符！</p><p> <code>$postname</code>是你文章的标题，执行完后会在<code>$repo/source/_posts</code>目录下生成一个<code>$postname.md</code>的文件。</p></li><li><p>使用你喜欢的编辑器撰写一篇markdown文章</p><p> 使用一个你喜欢的markdown编辑器打开上一步生成的<code>$repo/source/_posts/$postname.md</code>，按照正常的文章编辑即可，需要注意的只有以下几点：</p><ol><li><p>文章属性字段</p><p> 在文章一开头有形如这样的一段代码：</p> <figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs text">---<br>title: $postname<br>date: $createtime<br>---<br></code></pre></div></td></tr></table></figure><p> 你可以在其中加入如下字段：</p><p> <code>title</code>: 文章的标题，建议更改</p><p> <code>author</code>: 文章的作者</p><p> <code>date</code>: 文章的修改日期(会自动更改)</p><p> <code>tags</code>: 文章的标签，可以多个</p><p> <code>banner_img</code>: 文章的背景图片，仅支持外链</p><p> <code>category</code>: 文章的分类</p><p> 示例如下：</p> <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">---<br>title: 数据结构算法<br>date: 2021-08-04 09:27:54<br>author: Vector<br>tags:<br><span class="hljs-code">    [</span><br><span class="hljs-code">        C++,</span><br><span class="hljs-code">        Datastructures,</span><br><span class="hljs-code">        Algorithm,</span><br><span class="hljs-code">        STL</span><br><span class="hljs-code">    ]</span><br><span class="hljs-code">category: Courses</span><br><span class="hljs-code">---</span><br></code></pre></div></td></tr></table></figure></li><li><p>文章摘要</p><p> 在上面那一段文章属性结束后，可以自己定义文章摘要，如下所示：</p> <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">$abstract<br><br>&lt;!--more--&gt;<br></code></pre></div></td></tr></table></figure><p> 在<code>&lt;!--more--&gt;</code>标签以前的都是摘要，如果没有写摘要的话系统就会自动节选文章的前一百个字作为文章的摘要。</p></li><li><p>公式与图形</p><p> 我们适配了mermaid作为图表驱动引擎，可以在文章中使用mermaid：</p> <figure class="highlight markdown"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown">graph LR;<br>A--&gt;B;<br>A--&gt;C; <br>B--&gt;D;<br>C--&gt;D;<br></code></pre></div></td></tr></table></figure><p> 效果：</p> <pre><code class=" mermaid">graph LR;A--&gt;B;A--&gt;C; B--&gt;D;C--&gt;D;</code></pre><p> 我们还适配了mathjax作为公式驱动引擎，可以在文章中使用公式：</p> <figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs latex">$$<br>\begin&#123;aligned&#125;<br>\left| \bigcup_&#123;i=1&#125;^&#123;n&#125; S_i \right| &amp;= \sum_&#123;i&#125; | S_i | - \sum_&#123;i&lt;j&#125; | S_i \cap S_j | + \sum_&#123;i&lt;j&lt;k&#125; |S_i \cap S_j \cap S_k | - \cdots \\ <br>&amp; \quad + (-1)^&#123;m-1&#125; \sum_&#123;a_i&lt;a_&#123;i+1&#125; &#125; \left| \bigcap_&#123;i=1&#125;^&#123;m&#125; S_&#123;a_i&#125; \right| + \cdots + (-1)^&#123;n-1&#125; \left| S_1 \cap \cdots \cap S_n \right|<br>\end&#123;aligned&#125;<br>$$<br></code></pre></div></td></tr></table></figure><p> 效果：</p><script type="math/tex; mode=display"> \begin{aligned} \left| \bigcup_{i=1}^{n} S_i \right| &= \sum_{i} | S_i | - \sum_{i<j} | S_i \cap S_j | + \sum_{i<j<k} |S_i \cap S_j \cap S_k | - \cdots \\  & \quad + (-1)^{m-1} \sum_{a_i<a_{i+1} } \left| \bigcap_{i=1}^{m} S_{a_i} \right| + \cdots + (-1)^{n-1} \left| S_1 \cap \cdots \cap S_n \right| \end{aligned}</script></li></ol></li></ol><h3 id="发起pull-request"><a href="#发起pull-request" class="headerlink" title="发起pull request"></a>发起pull request</h3><p>在<a href="https://gitea.swu-acm.cn/SWU-ACM-Lab/original-swu-blog">original-swu-blog</a>页面提交pull request，按实际情况填写字段即可。</p><h3 id="等待合并"><a href="#等待合并" class="headerlink" title="等待合并"></a>等待合并</h3><p>如果审核通过的话，你的文章就会在博客站内发布了。</p><h2 id="Errors"><a href="#Errors" class="headerlink" title="Errors"></a>Errors</h2><p>你可以通过如下方式提交你的问题：</p><ol><li>在下方评论区留下你的问题</li><li>【推荐】在<a href="https://gitea.swu-acm.cn/SWU-ACM-Lab/original-swu-blog">original-swu-blog</a>提交Issue</li></ol><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Windows请直接到<a href="https://github.com/coreybutler/nvm-windows/releases"><code>nvm-windows</code>仓库</a>下载安装包。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>由于版本可能发生更迭，建议前往<a href="https://gitea.swu-acm.cn/mirrors/nvm">mirrors/nvm</a>查看最新的安装语句。<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>如果你使用的是bash，请在bashrc中添加，如果你使用的是zsh，请在zshrc中添加，其他shell请按照实际情况添加。<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:4" class="footnote-text"><span>只有ACM实验室的注册成员且被分配了权限，才能访问该仓库。<a href="#fnref:4" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构算法</title>
      <link href="/2021/08/04/Datastructures-Algorithm/"/>
      <url>/2021/08/04/Datastructures-Algorithm/</url>
      
        <content type="html"><![CDATA[<p>数据结构是本科期间的一门极其重要的课程，本文主要介绍了各种数据结构中的常用算法。</p><span id="more"></span><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="一、生成树"><a href="#一、生成树" class="headerlink" title="一、生成树"></a>一、生成树</h3><p>兄贵，学习MST​之前先来了解一下什么是生成树吧，概念如下</p><blockquote><p>对于无向带权图G和一棵树T来说，如果T是G的子图，则称T为G的树，如果T是G的生成子图，则称T是G的生成树。</p><p>简而言之，生成树是一个极小连通子图，它含有图中全部顶点，但只有n-1条边。</p></blockquote><h3 id="二、最小生成树"><a href="#二、最小生成树" class="headerlink" title="二、最小生成树"></a>二、最小生成树</h3><p>最小生成树(Minimum cost Spanning Tree)，就是所有生成树中各边权值之和最小的那个生成树。</p><p><img src="https://z3.ax1x.com/2021/04/05/cMEOte.png" alt="cMEOte.png"></p><blockquote><p><strong>构造最小生成树的准则</strong></p><ul><li>必须只使用该网络中的边来构造最小生成树；</li><li>必须使用且仅使用<em>n</em>-1条边来联结网络中的<em>n</em>个顶点；</li><li>不能使用产生回路的边。</li></ul></blockquote><p>对于最小生成树，常见的生成算法有两种：$Kruskal$算法和$Prim$算法，<a href="https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=5353145092427265999">参考链接</a></p><h3 id="三、Kruskal算法"><a href="#三、Kruskal算法" class="headerlink" title="三、Kruskal算法"></a>三、Kruskal算法</h3><p><strong>定义</strong></p><p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。（贪心思想）</p><p><strong>具体步骤</strong></p><ol><li><p>把图中的所有边按代价从小到大排序； </p></li><li><p>把图中的$n$个顶点看成独立的$n$棵树组成的森林； </p></li><li><p>按权值从小到大选择边，所选的边连接的两个顶点$ui,vi$。$ui,vi$,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 </p></li><li><p>重复3,直到所有顶点都在一颗树内或者有$n-1$条边为止。</p></li></ol><p><strong>步骤演示</strong></p><p><a href="https://imgtu.com/i/cMEXfH"><img src="https://z3.ax1x.com/2021/04/05/cMEXfH.png" alt="cMEXfH.png"></a></p><h3 id="四、Prim算法"><a href="#四、Prim算法" class="headerlink" title="四、Prim算法"></a>四、Prim算法</h3><p><strong>定义</strong></p><p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点$s$开始，逐渐长大覆盖整个连通网的所有顶点。</p><p><strong>具体步骤</strong></p><ol><li><p>从任意一个顶点开始构造生成树，将该顶点加入生成树中，用一个一维数组selected来标记哪些顶点已经加入了生成树。</p></li><li><p>用数组$minDist$记录生成树到各个顶点的距离，最初生成树中之后1号 顶点，有直连边时，数组$minDist$中存储的就是1号顶点到该顶点的边的权值，没有直连边的时候就是INF，即初始化$minDist$数组。</p></li><li><p>从数组$minDist$中选出离生成树最近的顶点（假设这个顶点为j）加入到生成树中（即在数组$minDist$中找到最小值）。再以j为中间点，更新生成树到每一个非树顶点的距离（松弛）， 即如果$minDist[k]&gt;e[j][k]$则更新$minDist[k]=e[j][k]$。</p></li><li><p>重复第三步，直到生成树中有n个顶点为止。</p></li></ol><p><strong>步骤演示</strong></p><p><img src="https://z3.ax1x.com/2021/04/05/cMELkD.png" alt="cMELkD.png"></p><h3 id="五、两种算法的比较"><a href="#五、两种算法的比较" class="headerlink" title="五、两种算法的比较"></a>五、两种算法的比较</h3><p><strong>从策略上来说</strong></p><p>Prim算法是直接查找，多次寻找邻边的权重最小值</p><p>Kruskal是需要先对权重排序后查找的</p><p><strong>从时间复杂度分析</strong></p><p>prim: 该算法的时间复杂度为$O(n2)$。 与图中边数无关，该算法适合于<strong>稠密图</strong></p><p>kruskal: 时间复杂度为$O(eloge)$。 适合<strong>稀疏图</strong></p><p><strong>所以说</strong></p><p>Kruskal在算法效率上是比Prim快的，因为Kruskal只需一次对权重的排序就能找到最小生成树；而Prim算法需要多次对邻边排序才能找到</p><h3 id="六、练习"><a href="#六、练习" class="headerlink" title="六、练习"></a>六、练习</h3><p><a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a></p><p><strong>Kruskal算法实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> gen[<span class="hljs-number">5005</span>],n,m,ans,cnt;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//左边的点</span><br>    <span class="hljs-keyword">int</span> v;<span class="hljs-comment">//右边的点</span><br>    <span class="hljs-keyword">int</span> w;<span class="hljs-comment">//权值</span><br>&#125;edge[<span class="hljs-number">200005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge a,Edge b)</span></span>&#123;<span class="hljs-comment">//排序方法</span><br>    <span class="hljs-keyword">return</span> a.w&lt;b.w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(gen[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> gen[x]=<span class="hljs-built_in">find</span>(gen[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edge+<span class="hljs-number">1</span>,edge+m+<span class="hljs-number">1</span>,cmp);<span class="hljs-comment">//按照权值排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">int</span> eu=<span class="hljs-built_in">find</span>(edge[i].u);<span class="hljs-comment">//找到左边点和右边点的老大</span><br>        <span class="hljs-keyword">int</span> ev=<span class="hljs-built_in">find</span>(edge[i].v);<br>        <span class="hljs-keyword">if</span>(ev==eu)&#123;<span class="hljs-comment">//如果老大是一个，说明这俩在一个集合中，跳过</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-comment">//否则</span><br>        ans+=edge[i].w;<span class="hljs-comment">//加上权值</span><br>        gen[ev]=eu;<span class="hljs-comment">//连接两个并查集</span><br>        cnt++;<br>        <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//退出的条件</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        gen[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;edge[i].u&gt;&gt;edge[i].v&gt;&gt;edge[i].w;<br>    &#125;<br>    <span class="hljs-built_in">kruskal</span>();<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Prim算法实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">200001</span>;<br><span class="hljs-keyword">bool</span> selected[maxn];<span class="hljs-comment">//是否被选中，初始为0</span><br><span class="hljs-keyword">int</span> minDist[maxn];<span class="hljs-comment">//最小值，初始为INF</span><br><span class="hljs-keyword">int</span> parent[maxn];<span class="hljs-comment">//存储最小值的那个边的父亲，初始为-1，代表不存在</span><br><span class="hljs-keyword">int</span> n,m,cnt,ans;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br><span class="hljs-keyword">int</span> begin;<br><span class="hljs-keyword">int</span> end;<br><span class="hljs-keyword">int</span> longth;<br>&#125;edge[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>cnt++;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">if</span>(edge[i].begin==x&amp;&amp;minDist[edge[i].end]&gt;edge[i].longth)&#123;<br>minDist[edge[i].end]=edge[i].longth;<br>parent[edge[i].end]=x;<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(edge[i].end==x&amp;&amp;minDist[edge[i].begin]&gt;edge[i].longth)&#123;<br>minDist[edge[i].begin]=edge[i].longth;<br>parent[edge[i].begin]=x;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;edge[i].begin&gt;&gt;edge[i].end&gt;&gt;edge[i].longth;<br>&#125;<br><span class="hljs-built_in">memset</span>(minDist,<span class="hljs-number">0x3f3f3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(minDist));<span class="hljs-comment">//minDist初始化</span><br>selected[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//先选择1加入最小生成树中</span><br><span class="hljs-built_in">Prim</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//遍历查找</span><br><span class="hljs-keyword">while</span>(cnt!=n)&#123;<span class="hljs-comment">//循环</span><br><span class="hljs-keyword">int</span> minn=<span class="hljs-number">0x3f3f3f</span>;<br><span class="hljs-keyword">int</span> chose=<span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!selected[i]&amp;&amp;minDist[i]&lt;minn)&#123;<br>minn=minDist[i];<br>chose=i;<br>&#125;<br>&#125;<br>selected[chose]=<span class="hljs-number">1</span>;<br>ans+=minn;<br><span class="hljs-built_in">Prim</span>(chose);<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><blockquote><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。</p></blockquote><h3 id="二、应用情境"><a href="#二、应用情境" class="headerlink" title="二、应用情境"></a>二、应用情境</h3><ul><li>由于最小生成树需要维护连通性，并查集刚好可以做到通过构建树来判断元素之间的连通性、查找出两个元素是否位于同一元素。所以并查集在$MST$的建立过程中有着很大的作用</li><li>集合操作</li></ul><h3 id="三、操作"><a href="#三、操作" class="headerlink" title="三、操作"></a>三、操作</h3><p>在最开始的时候，每个元素都可以看做是一个单独的集合。我们在不断地进行查询和合并（并查集）请求操作中，元素之间进行合并。</p><p>一般都会用帮派来形容并查集的操作。每个集合都有一个帮主（人为设定），他统领着集合中的所有元素；在每一次帮派大战（合并），战败的集合便会被战胜的集合吞并，战胜集合的帮主成为合并帮主的新帮主，循环往复。</p><p>执行查询操作也很简单，只需要看他们的帮主是不是一个人即可~</p><p>1.<strong>初始化</strong></p><p>把每个点所在集合初始化为其自身。（自己是自己的帮主）</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    f[i]=i;<span class="hljs-comment">//初始化</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>2.<strong>查找</strong></p><blockquote><p>查找元素所在的集合，即总帮主</p></blockquote><ul><li>普通做法（递归）</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[k]==k) <span class="hljs-keyword">return</span> k;<span class="hljs-comment">//如果自己是自己所在集合的帮主，那它就是总帮主</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[k]);<span class="hljs-comment">//如果不是，就找他老大哥的老大哥</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>路径压缩</li></ul><p>上面这种做法很慢，所以我们可以直接在查找的过程中顺便把中间人士都指向总帮主</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>   <span class="hljs-keyword">if</span>(f[k]==k) <span class="hljs-keyword">return</span> k;<span class="hljs-comment">//如果自己是自己所在集合的帮主，那它就是总帮主</span><br>    <span class="hljs-keyword">return</span> f[k]=<span class="hljs-built_in">find</span>(f[k]);<span class="hljs-comment">//把图中的人的老大哥都变成总帮主</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>3.查询</strong></p><blockquote><p>查询两个元素是否在同一个集合中</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(p1)==<span class="hljs-built_in">find</span>(p2))&#123;<span class="hljs-comment">//如果这俩隶属于同一个帮派</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>4.合并</strong></p><blockquote><p>把两个不相交的集合合并为一个集合</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">f[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);<span class="hljs-comment">//让b和a的帮主变成一个人</span><br></code></pre></div></td></tr></table></figure><h3 id="四、练习"><a href="#四、练习" class="headerlink" title="四、练习"></a>四、练习</h3><p><a href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集</a></p><p><strong>AC代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">10005</span>;<br><span class="hljs-keyword">int</span> n,m,f[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[k]==k) <span class="hljs-keyword">return</span> k;<span class="hljs-comment">//如果自己的老大就是自己，那它就是总老大</span><br>    <span class="hljs-keyword">return</span> f[k]=<span class="hljs-built_in">find</span>(f[k]);<span class="hljs-comment">//使途中经过的人的大哥也变成老大</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        f[i]=i;<span class="hljs-comment">//初始化i的老大为自己</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,p1,p2,p3;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3;<br>        <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果是执行合并操作</span><br>            f[<span class="hljs-built_in">find</span>(p2)]=<span class="hljs-built_in">find</span>(p3);<span class="hljs-comment">//让p2的老大变成p3的老大</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//查询操作</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(p2)==<span class="hljs-built_in">find</span>(p3))&#123;<span class="hljs-comment">//如果p2的老大和p3的老大是一个人</span><br>                cout&lt;&lt;<span class="hljs-string">&quot;Y&quot;</span>&lt;&lt;endl;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;N&quot;</span>&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>在学习拓扑排序之前，我们先来了解什么事AOV网。</p><h3 id="一、AOV网"><a href="#一、AOV网" class="headerlink" title="一、AOV网"></a>一、AOV网</h3><blockquote><ul><li>用顶点表示活动，用弧表示活动间优先关系的<strong>有向图</strong>称为顶点表示活动的网(Activity On Vertex network)，简称AOV网。</li><li>在网中，若从顶点$i$到顶点$j$有一条有向路径，则$i$是$j$的前驱，$j$是$i$的后继。若$<v_i,v_j>$是图中有向边，则$v_i$是$v_j$的直接前驱；$v_j$是$v_i$的直接后继。</li><li><strong>AOV网中不允许有回路</strong>，这意味着某项活动以自己为先决条件。</li><li><strong>对于给定的AOV网应首先判定网中是否存在环</strong>。检测的办法是对有向图构造其顶点的<strong>拓扑有序序列</strong>，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。<br><a href="https://imgtu.com/i/cMtvOf"><img src="https://z3.ax1x.com/2021/04/05/cMtvOf.png" alt="AOV.png"></a></li></ul></blockquote><p>拓扑排序就是在AOV的基础上进行的。</p><h3 id="二、AOE网"><a href="#二、AOE网" class="headerlink" title="二、AOE网"></a>二、AOE网</h3><blockquote><p>AOE网(Activity On Edge)：也叫边表示活动的网。AOE网是一个带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>拓扑排序(Topological Sort) 是由某个集合上的一个偏序得到该集合上的一个全序，这个操作就称之为拓扑排序。</p></blockquote><p>例如，一个软件专业的学生必须学习一系列基本课程，其中有些课是基础课，它独立于其它课程，如《高等数学》；而另一些课程必须在学完作为它的基础的先修课程才能开始。如在《程序设计基础》和《离散数学》学完之前就不能开始学习《数据结构》。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote><ul><li>选择一个入度为 0 的顶点并输出。</li><li>从 AOV 网中删除此顶点及以此顶点为起点的所有关联边。</li><li>重复上述两步，直到不存在入度为 0 的顶点为止。</li><li>若输出的顶点数小于 AOV 网中的顶点数，则说明 AOV 网中回路，不是一个标准的 AOV 网。</li></ul></blockquote><p><a href="https://imgtu.com/i/cMtbYd"><img src="https://z3.ax1x.com/2021/04/05/cMtbYd.png" alt="cMtbYd.png"></a></p><p><a href="https://www.bilibili.com/video/BV1Ut41197TE?from=search&amp;seid=17211423774363355925">更加具体的过程请参考</a></p><h4 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h4><p>接下来我们来练习一道有关拓扑排序的<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1285">题目</a>。</p><blockquote><p>这道题是一道简单的拓扑排序，题中已经给出了<code>具体的提示</code>(其他说明：符合条件的排名可能不是唯一的，<code>此时要求输出时编号小的队伍在前</code>；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名)。<br>正是练习拓扑排序的好机会。</p></blockquote><p><strong>AC代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1000</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;vec[maxn]; <span class="hljs-comment">// 邻接表建图。</span><br><span class="hljs-keyword">int</span> du[maxn];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; s;<span class="hljs-comment">//使用优先队列，来保证输出时编号小的队伍在前</span><br><span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(!du[i])<span class="hljs-comment">//将入度为0的节点入队</span><br>s.<span class="hljs-built_in">push</span>(i);<br>&#125;<br><span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">int</span> now=s.<span class="hljs-built_in">top</span>();<br>         s.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<br>&#123;<br>cout&lt;&lt;now;<br>flag=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;now; <span class="hljs-comment">// 最后一名没有空格</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vec[now].<span class="hljs-built_in">size</span>();i++) <span class="hljs-comment">//除去与该节点相关的节点的关联边。</span><br>&#123;<br><span class="hljs-keyword">if</span>(--du[vec[now][i]]==<span class="hljs-number">0</span>)<br>s.<span class="hljs-built_in">push</span>(vec[now][i]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)<br>&#123;<br><span class="hljs-built_in">memset</span>(du,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(du));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>vec[i].<span class="hljs-built_in">clear</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-keyword">int</span> a,b;<br>cin&gt;&gt;a&gt;&gt;b;<br>vec[a].<span class="hljs-built_in">push_back</span>(b);<br>du[b]++;<br>&#125;<br><span class="hljs-built_in">topsort</span>();<br>cout&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></div></td></tr></table></figure><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3342">如果有兴趣可以试试做下这道题，判断图中是否有环</a></p><h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="一、定义-1"><a href="#一、定义-1" class="headerlink" title="一、定义"></a>一、定义</h3><blockquote><p>如果从图中某一顶点(称为源点)到达另一顶点(称为终点)的路径可能不止一条，如何找到一条路径，使得沿此路径各边上的权值总和达到最小。</p></blockquote><p>解决这个问题，我们有两种算法：Dijkstra算法 和 Floyd算法。</p><h3 id="二、Dijkstra算法"><a href="#二、Dijkstra算法" class="headerlink" title="二、Dijkstra算法"></a>二、Dijkstra算法</h3><p>Dijkstra算法是单源最短路径，也就是说一个点到其他所有点的最短路径。<br><strong>它的主要思想就是根据已经确定了的点的距离，来确定该点相邻顶点的距离，不断的向外散射，直到所以的点的到起点的最短距离确定为止。</strong>  </p><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><blockquote><ul><li>把图中所有顶点分成两组，第一组包括已确定最短路径的顶点，第二组包括尚未确定最短路径的顶点，按最短路径长度递增的顺序逐个把第二组的顶点加到第一组中去，直至从$v_0$出发可以到达的所有顶点都包括到第一组中。</li><li>在这过程中，总保持从$v_0$到第一组各顶点的最短路径长度都不大于从$v_0$到第二组的任何顶点的最短路径长度。<h4 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h4></li><li>一开始第一组只包括顶点$v_0$，第二组包括其他所有的顶点，$v_0$对应的距离为0。</li><li>第二组的顶点对应的距离是这样确定的：若图中有边$<v_0，v_i>$， vi的距离为此边所带的权值，否则$v_i$的距离为一个很大的数（大于所有顶点间的路径长度）。</li><li>然后每次从第二组的顶点中选一个其距离值为最小的$v_m$加入到第一组中。</li><li>每往第一组加入一个顶点$v_m$ ，就要对第二组中的各个顶点的距离值进行一次修正。若加进$V_m$做中间顶点使从$v_0$到$v_j$的最短路径比不加$v_m$的路径为短，则要修改$v_j$的距离值。修改后再选距离值最小的顶点加入到第一组中。</li><li>重复3和4步骤直至所有点都在第一组中。</li></ul></blockquote><p><a href="https://www.bilibili.com/video/BV1q4411M7r9?from=search&amp;seid=4117483000935554948">动画演示</a></p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote><p>$O(n^2)$</p><h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span>   <span class="hljs-comment">//s是起点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(visit, <span class="hljs-literal">false</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visit));    <br>visit[s] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//将s加入第一组集合</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br><span class="hljs-comment">//dist[i] 代表着s带i点的距离</span><br>        dist[i] = graph[s][i];<span class="hljs-comment">//对graph进行了处理，初始化矩阵全部初始化为无穷大。</span><br>    &#125;<br>     <br>    <span class="hljs-keyword">int</span> index;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">// 求出s到n-1个点的最短路径。</span><br>        <span class="hljs-keyword">int</span> mincost = INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//找出最小值那个点</span><br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; dist[j] &lt; mincost)&#123;<br>                mincost = dist[j];<br>                index = j;    <br>            &#125;    <br>        &#125;<br>        visit[index] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//把这个点加入第一组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//更新距离</span><br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; dist[j] &gt; dist[index] + graph[index][j])&#123;<br>                dist[j] = dist[index] + graph[index][j];<br>            &#125;    <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="题目练习-1"><a href="#题目练习-1" class="headerlink" title="题目练习"></a>题目练习</h4><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">一道模板题</a><br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 0x3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">200</span>][<span class="hljs-number">200</span>];<br><span class="hljs-keyword">int</span> d[<span class="hljs-number">200</span>]; <br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">200</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;<br><span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>vis[s] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>d[i] = g[s][i];<br>&#125;<br><span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">int</span> mincost = inf;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br><span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;mincost)&#123;<br>k = j;<br>mincost = d[j];<br>&#125;<br>&#125;<br>vis[k] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br><span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&gt;d[k]+g[k][j])&#123;<br>d[j] = d[k]+g[k][j];<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;<br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span> &amp;&amp; m==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">memset</span>(g,inf,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//建图 </span><br><span class="hljs-keyword">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>g[a][b]=g[b][a]=c;<span class="hljs-comment">//无向图</span><br>&#125;<br><span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//从起点1出发</span><br>cout&lt;&lt;d[n]&lt;&lt;endl;<br>&#125;<br>&#125;<br><span class="hljs-comment">//还有一些题需要输出路径，这时只需要加一个path[][]数组即可。</span><br></code></pre></div></td></tr></table></figure></p><h3 id="三、Floyd算法"><a href="#三、Floyd算法" class="headerlink" title="三、Floyd算法"></a>三、Floyd算法</h3><p>Floyd算法是每一对顶点之间的最短路径。在此有两种解决方法：每次以一个顶点为源点，重复执行Dijkstra算法n次 和 弗洛伊德(Floyd)算法。</p><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>逐个顶点试探</p><ul><li>初始时设置一个$n$阶方阵，令其对角线元素为$0$，若存在弧$<vi,vj>$，则对应元素为权值；否则为$\infty$。</li><li>逐步试着在原直接路径中增加中间顶点，若加入中间点后路径变短，则修改之；否则，维持原值。</li><li>所有顶点试探完毕，算法结束。</li></ul></blockquote><p><a href="https://www.bilibili.com/video/BV1LE411R7CS?from=search&amp;seid=4295088178287909313">详细过程</a></p><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Floyd算法的时间复杂度和重复执行Dijkstra算法n次的时间复杂度相同都是$O(n^3)$。但是Floyd的形式更加简单。</p><h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)&#123; <span class="hljs-comment">//作为循环中间点的k必须放在最外一层循环 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(dist[i][j] &gt; dist[i][k] + dist[k][j])&#123;<br>                    dist[i][j] = dist[i][k] + dist[k][j];    <span class="hljs-comment">//dist[i][j]得出的是i到j的最短路径 </span><br>                &#125;     <br>            &#125;    <br>        &#125;    <br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>在了解下列算法之前我们介绍一些概念性问题。</p><blockquote><ul><li>有向图G中，以顶点v为起点的弧的数目称为v的出度，记做$deg+ （v）$；以顶点v为终点的弧的数目称为v的入度，记做$deg-（v）$。</li><li>如果在有向图G中，有一条$<u，v>$向道路，则$v$称为$u$可达的，或者说，从$u$可达$v$。</li><li>如果有向图$G$的<strong>任意两个顶点</strong>都<strong>互相</strong>可达，则称图$G$是强连通图，如果有向图G存在两顶点$u$和$v$使得$u$不能到$v$，或者$v$不能到$u$，则称图$G$是强非连通图。</li><li>如果有向图$G$不是强连通图，他的子图$G2$是强连通图，点$v$属于$G2$，任意包含$v$强连通子图也是$G2$的子图，则称$G2$是有向图G的极大强连通子图，也称<strong>强连通分量</strong>(是对于极大连通子图来说的)。</li><li><strong>强连通</strong>其实就是指图中有两点$u，v$。使得能够找到有向路径从$u$到$v$并且也能够找到有向路径从$v$到$u$，则称$u$，$v$是强连通的。</li></ul></blockquote><p>我们来通过下图来加强对这些概念的理解<br><a href="https://imgtu.com/i/cl77qI"><img src="https://z3.ax1x.com/2021/04/06/cl77qI.png" alt="cl77qI.png"></a><br>{1,2,3,4}为一个强连通分量,<strong>{5},{6}也分别是两个强连通分量</strong>。</p><p>那我们该如何求得强连通分量呢？下我们学习三个算法：$Tarjan$算法、<br>$Kosaraju$算法 和 $Gabow$算法。</p><h3 id="一、-Tarjan-算法"><a href="#一、-Tarjan-算法" class="headerlink" title="一、$Tarjan$算法"></a>一、$Tarjan$算法</h3><p>Tarjan的主要思想就是采用<code>dfs</code>的回溯来找到比他更早的时间点来确定他们是否为同一强连通分量。那么这点中一定有环，我们就可以利用这个环来判断强连通分量。<br>那么具体操作是什么呢?</p><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol><li>我们先定义两个数组$dfn[]$ 和 $low[]$，其中$dfn[u]$代表搜索到$u$时的次数编号，$low[u]$为$u$或者$u$的子树能够追寻的最小编号。</li><li>初始化$low[u] = dfn[u]$.</li><li>一直遍历到没有其他点可以走或者已经走过的点，维护$low[]$。 $low[u] = min (low[u],low[v])$其中$v$是$u$指向且<code>还在栈中</code>的点。</li><li>判断$dfn[u] == low[u]$，若成立，则找到了一个强连通量。最后出栈。这里为什么呢?因为点$u$先进栈，那么dfs到最后一个点时，那么这个点指向之前入栈的点，那么它的$low[u]$肯定是较小的，所以更新为low的值为$u$的low，以此慢慢回溯得到的就是$dfn[u] == low[u]$。因为有环的存在，那么一定会有一个点指向起始点，那么这个点更新后他的low就是这个连通分量中最小的，所以一路回溯下去，最终就会的得到$dfn[u] == low[u]$。</li><li>以此重复循环以上步骤就可以得出有多少个连通分量和那些点事同一个连通分量。</li><li>下面我将以上图中{1,2,3,4}连通量中的1节点开始举例。这里为了方便不考虑5，6节点。<blockquote><ul><li>$low[1] = dfn[1] = 1$</li><li>$low[3] = dfn[3] = 2$</li><li>$low[4] = dfn[4] = 3$</li><li>$low[4] = min(low[4],low[1]) = 1$</li><li>$low[3] = min(low[3],low[4]) = 1$</li><li>$low[2] = dfn[2] = 4$</li><li>$low[2] = min(low[2],low[4]) = 1$</li><li>$low[1] = min(low[2],low[1] = 1)$</li><li>$low[1] = dfn[1] = 1$<br>即找到了一个连通分量。</li></ul></blockquote></li></ol><p>这里可能表示不清楚或者有错误，具体可以参考下<a href="https://www.bilibili.com/video/BV19J411J7AZ?from=search&amp;seid=15425029704146605635">这个视频</a><br><strong>经过测试，一个连通的dfn不一定全部相同</strong></p><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>邻接表：$O(V+E)$<br>邻接矩阵：$O(V^2)$</p><h4 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>instack[u] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//u是否在栈中</span><br>stack[top] = u;<span class="hljs-comment">//入栈</span><br>low[u] = dfn[u] = ++cnt;<span class="hljs-comment">//初始化</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vec[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">int</span> v = vec[u][i];<span class="hljs-comment">//下一个节点</span><br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfn</span>(v))&#123;<br><span class="hljs-built_in">tarjan</span>(v);<br><span class="hljs-comment">//回溯时更新</span><br>low[u] = <span class="hljs-built_in">min</span>(low[u],low[v]);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">instack</span>(v))&#123;<span class="hljs-comment">//这个点还在栈中（这尤为重要，若要一个点个指向一个强连通分量，没有这句话，那么low将会变小）</span><br><span class="hljs-comment">/*访问到根节点，或者其他情况.这里需要注意一下。强连通图中可以用low[u] = min(low[u],low[v]);但是在割点这种问题就必须要下面这种格式。推荐使用这种*/</span><br>low[u] = <span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">int</span> j;<br><span class="hljs-keyword">if</span>(low[u] == dfn[u])&#123;<span class="hljs-comment">//判断</span><br>ans++;<br><span class="hljs-keyword">do</span>&#123;<br>j=stack[top--];<br>instack[j] = <span class="hljs-literal">false</span>;<br>Belong[j] = ans;<span class="hljs-comment">//染色，也就是哪一些是连通块。</span><br>&#125;<span class="hljs-keyword">while</span>(j!=u)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="题目练习-2"><a href="#题目练习-2" class="headerlink" title="题目练习"></a>题目练习</h4><p><a href="https://www.luogu.com.cn/problem/P2863">题链接</a><br>纯模板题<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> index;<span class="hljs-comment">//序数</span><br><span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//答案</span><br><span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">bool</span> instack[<span class="hljs-number">100010</span>];<span class="hljs-comment">//记录这个节点是否在栈中</span><br><span class="hljs-keyword">int</span> stack[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> dfn[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> low[<span class="hljs-number">100010</span>];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; M[<span class="hljs-number">100010</span>];<span class="hljs-comment">//图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">int</span> v;<br>low[u] = dfn[u] = ++index;<br>stack[++top] = u;<br>instack[u] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>v = M[u][i];<br><span class="hljs-keyword">if</span>(!dfn[v])&#123;<br><span class="hljs-built_in">tarjan</span>(v);<br>low[u] = <span class="hljs-built_in">min</span>(low[u],low[v]);<br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(instack[v])&#123;<br>low[u] = <span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>&#125; <br>&#125;<br><span class="hljs-keyword">if</span>(dfn[u] == low[u])&#123;<br><span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span>&#123;<br>v = stack[top--];<span class="hljs-comment">//出栈</span><br>x++;<br>instack[v] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//出栈</span><br>&#125;<span class="hljs-keyword">while</span>(u!=v);<br><span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ans++;<span class="hljs-comment">//如果这个强连通分量里面的节点数大于1</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">int</span> x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>M[x].<span class="hljs-built_in">push_back</span>(y);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!dfn[i])&#123;<span class="hljs-comment">//若没有被访问过 </span><br><span class="hljs-built_in">tarjan</span>(i);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="二、Kosaraju算法"><a href="#二、Kosaraju算法" class="headerlink" title="二、Kosaraju算法"></a>二、Kosaraju算法</h3><p>kosaraju算法进行两次dfs，第一次在原图上进行，并在结点递归调用返回时将结点压入一个栈中，第二次dfs在原图的反图上进行，并且初始点选择栈中最上面的点，每次dfs所访问的点构成一个强连通分量。</p><h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><blockquote><ul><li>返图与原图的强连通分量相同</li><li>若原图从分量I能走到分量II，则反图不能从分量I走到分量II</li></ul></blockquote><p>此算法的核心在于对于各个强连通分量进行了分离，也就是说，各个强连通分量之间无法到达。<br>那么这是如何实现的呢？</p><blockquote><ul><li>我们把这些强连通分量缩点（也就是是说一个强连通分量看为一个点），这样我们就得到了一个有向无环图（DAG）。</li><li>我先对这个有向无环图进图DFS遍历，那么先遍历的那个缩点是这次（可能会有多次）遍历序列的根，那么这个缩点可以达到其他的强连通分量。子树也是如此</li><li>那么第二次对原图取反，对于这个根缩点就是第一个访问的，那么对他来说就没有进入的边，那么再对它进行遍历那么得到的一定就是一个强连通分量。</li><li>接下来在对栈里的其他点进行遍历的时候也不会连通到这个点，因为它已经被标记了。<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4></li><li>对原图进行DFS，记录定点的后序遍历序列（入栈）</li><li>选出栈顶的顶点，对反图进行DFS，标记出能够遍历到的顶点，这些顶点就构成了一个强连通分量。</li><li>如果还有顶点没有被标记，重复过程2直至结束。<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>邻接表：$O(V+E)$<br>邻接矩阵：$O(V^2)$<br>但是tarjan的效率比Kosaraju高30%.<h4 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M1[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">int</span> next = M1[u][i];<br><span class="hljs-keyword">if</span>(!v1[next])&#123;<br>v1[next] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs1</span>(next);<br>&#125;<br>&#125;<br>stack[++top] = u;<span class="hljs-comment">//后序入栈 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<span class="hljs-comment">//对反图进行dfs </span><br>belongs[u] = j;<span class="hljs-comment">//染色，把同一强连通分量的点统一标记</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M2[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">int</span> next = M2[u][i];<br><span class="hljs-keyword">if</span>(!v2[next])&#123;<br>v2[next] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs2</span>(next);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></blockquote><h4 id="题目练习-3"><a href="#题目练习-3" class="headerlink" title="题目练习"></a>题目练习</h4><p>还是Tarjan的<a href="https://www.luogu.com.cn/problem/P2863">练习题</a><br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//答案</span><br><span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> x;<span class="hljs-comment">//记录该强连通节点的个数 </span><br><span class="hljs-keyword">bool</span> v1[<span class="hljs-number">100010</span>];<span class="hljs-comment">//第一遍历的标记 </span><br><span class="hljs-keyword">bool</span> v2[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//第二次遍历的标记 </span><br><span class="hljs-keyword">int</span> stack[<span class="hljs-number">100010</span>];<span class="hljs-comment">//栈 </span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; M1[<span class="hljs-number">100010</span>];<span class="hljs-comment">//图</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; M2[<span class="hljs-number">100010</span>];<span class="hljs-comment">//反图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M1[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">int</span> next = M1[u][i];<br><span class="hljs-keyword">if</span>(!v1[next])&#123;<br>v1[next] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs1</span>(next);<br>&#125;<br>&#125;<br>stack[++top] = u;<span class="hljs-comment">//后序入栈 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<span class="hljs-comment">//对反图进行dfs </span><br>x++;<span class="hljs-comment">//记录 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M2[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">int</span> next = M2[u][i];<br><span class="hljs-keyword">if</span>(!v2[next])&#123;<br>v2[next] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs2</span>(next);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">int</span> x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>M1[x].<span class="hljs-built_in">push_back</span>(y);<br>M2[y].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//返图 </span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!v1[i])&#123;<span class="hljs-comment">//若没有被访问过 </span><br>v1[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs1</span>(i);<br>&#125;<br>&#125;<br><span class="hljs-keyword">while</span>(top)&#123;<br><span class="hljs-keyword">int</span> v = stack[top--];<span class="hljs-comment">//出栈</span><br>x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(!v2[v])&#123;<br>v2[v] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">dfs2</span>(v);<br>&#125; <br><span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) ans++;<br>&#125; <br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="三、-Gabow-算法"><a href="#三、-Gabow-算法" class="headerlink" title="三、$Gabow$算法"></a>三、$Gabow$算法</h3><p>Gabow算法的思想与Tarjan一致。<br>该算法使用了两个栈，一个顶点栈，另外一个栈的功能类似于Tarjan算法中的数组low。从起始顶点u处开始进行DFS过程中，当一条回路显示这组顶点都属于同一个强连通分支时，就会弹出栈二中顶点，只留下回边的目的顶点，也即搜索的起点u。</p><p>当回溯到递归起始顶点u时，如果此时该顶点在栈二顶部，则说明该顶点是一个强联通分量的起始顶点，那么在该顶点之后搜索的顶点都属于同一个强连通分支。于是，从第一个栈中弹出这些点，形成一个强连通分支。</p><h3 id="题目练习-4"><a href="#题目练习-4" class="headerlink" title="题目练习"></a>题目练习</h3><p>还是Tarjan的<a href="https://www.luogu.com.cn/problem/P2863">练习题</a><br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//答案</span><br><span class="hljs-keyword">int</span> t1;<span class="hljs-comment">//栈顶</span><br><span class="hljs-keyword">int</span> t2;<span class="hljs-comment">//栈顶 </span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> index;<br><span class="hljs-keyword">int</span> x;<span class="hljs-comment">//记录该强连通节点的个数 </span><br><span class="hljs-keyword">int</span> dfn[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> stack_2[<span class="hljs-number">100010</span>]; <br><span class="hljs-keyword">int</span> stack_1[<span class="hljs-number">100010</span>];<span class="hljs-comment">//栈 </span><br><span class="hljs-keyword">int</span> instack[<span class="hljs-number">100010</span>];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; M[<span class="hljs-number">100010</span>];<span class="hljs-comment">//图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Gabow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>dfn[u] = ++index;<br>stack_1[++t1] = stack_2[++t2] = u;<br>instack[u] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">int</span> v = M[u][i];<br><span class="hljs-keyword">if</span>(!dfn[v])&#123;<br><span class="hljs-built_in">Gabow</span>(v);<br><span class="hljs-comment">//while(dfn[stack_2[t2]]&gt;dfn[v]) t2--; 这里加不加好像都可以</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(instack[v])&#123;<br><span class="hljs-keyword">while</span>(dfn[stack_2[t2]]&gt;dfn[v]) t2--;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(u==stack_2[t2])&#123;<br><span class="hljs-keyword">int</span> j;<br><span class="hljs-keyword">do</span>&#123;<br>j = stack_1[t1--];<br>x++;<br>instack[j] = <span class="hljs-number">0</span>;<br>&#125;<span class="hljs-keyword">while</span>(u!=j);<br>&#125;<br><span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ans++;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-keyword">int</span> x,y;<br>cin&gt;&gt;x&gt;&gt;y;<br>M[x].<span class="hljs-built_in">push_back</span>(y);<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(!dfn[i])&#123;<span class="hljs-comment">//若没有被访问过 </span><br>x = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">Gabow</span>(i);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
            <tag> Datastructures </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模版库</title>
      <link href="/2021/08/04/CXX-STL/"/>
      <url>/2021/08/04/CXX-STL/</url>
      
        <content type="html"><![CDATA[<p>STL即标准模板库(Standard Template Library)，隶属于C++标准库，包含了一些常用的模板化的数据结构和算法。STL作为模板，拥有极强的兼容性和普适性，大大提高了我们编写代码的效率，使得其在各大算法比赛中都得到了广泛的应用。</p><span id="more"></span><p>本文将STL的学习分为两个板块：<code>container</code>和<code>algorithm</code>，各个板块只介绍一些在ACM/ICPC等比赛中常用的函数和功能，如果哪里有内容错误还请同学们海涵和反馈。</p><h2 id="容器container"><a href="#容器container" class="headerlink" title="容器container"></a>容器container</h2><p><img src="https://oi-wiki.org/lang/csl/images/container1.png" alt="img"></p><h3 id="一、向量Vector"><a href="#一、向量Vector" class="headerlink" title="一、向量Vector"></a>一、向量Vector</h3><blockquote><p><code>std::vector</code>是STL提供的能够存放任意类型的、内存连续的、<strong>可变长度（动态）</strong>的数组，可以提供线性复杂度的插入和删除。</p></blockquote><h4 id="Vector的优良特性"><a href="#Vector的优良特性" class="headerlink" title="Vector的优良特性"></a>Vector的优良特性</h4><ul><li>可以动态分配内存<ul><li><code>vector</code>不像<code>c++</code>中普通数组一样需要在定义时设定大小，支持动态扩容，即数组的大小会随着你的插入/删除而变大/变小</li><li>允许存储的size也要比普通数组大</li></ul></li><li>便利的初始化</li><li>自带常用的函数</li></ul><h4 id="Vector使用方法"><a href="#Vector使用方法" class="headerlink" title="Vector使用方法"></a>Vector使用方法</h4><p><strong>1.构造函数</strong></p><p>为了可以使用vector，请在你的头文件中包含<code>#include&lt;vector&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 提示，T代表数据类型，可以是int/string/...，也可以是自己定义的数据类型</span><br>vector&lt;T&gt; v1;<span class="hljs-comment">//定义一个空的vector v1,元素类型为T,这也是我们最常用的一种初始化方法</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v2</span><span class="hljs-params">(v1)</span></span>;<span class="hljs-comment">//v2中包含v1所有元素的副本</span><br>vector&lt;T&gt; v2 = v1;<span class="hljs-comment">//等价于v2(v1)</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v3</span><span class="hljs-params">(n,val)</span></span>;<span class="hljs-comment">//v3包含了n个重复的元素，每个元素的值都是val</span><br><span class="hljs-function">vector&lt;T&gt; <span class="hljs-title">v4</span><span class="hljs-params">(n)</span></span>;<span class="hljs-comment">//v4包含了n个重复执行了值初始化的对象，换而言之就是规定了v4的size</span><br>vector&lt;T&gt; v5&#123;a,b,c...&#125;;<span class="hljs-comment">//v5包含了初始化个数的元素，每个元素被赋予相应的初始值</span><br>vector&lt;T&gt; v5=&#123;a,b,c...&#125;;<span class="hljs-comment">//等价于上条</span><br></code></pre></div></td></tr></table></figure><p><strong>2.元素的增删改</strong></p><ul><li><code>v.push_back(element)</code>：在尾部插入元素element</li><li><code>v.pop_back()</code>：在尾部删除一个元素</li><li><code>v.insert(pos,n,element)</code>：在pos位置前增加n个相同的元素element，n可省略不写，默认添加一个</li><li><p><code>v.erase(begin,end)</code>：删除v中<code>[begin,end)</code>范围内的所有元素</p></li><li><p><code>v.clear()</code>：清除所有元素</p></li></ul><p><strong>3.元素的访问</strong></p><ul><li><code>v.at(pos)</code>：返回v中pos位置的引用</li><li><code>v.front()</code>：返回v中首元素的引用</li><li><code>v.back()</code>：返回v中尾元素的引用</li><li><code>v.data()</code>：返回指向数组第一个元素的指针</li></ul><p><strong>4.迭代器</strong></p><blockquote><p>迭代器(Iterator)用来访问和检查STL容器中的对象，可以看作是一个数据指针</p><p>学过指针的朋友可以很简单的理解这里hahah</p><p>本文章暂时只介绍常用的一些迭代器，感兴趣的同学可以自学更多</p></blockquote><ul><li><code>v.begin()</code>：返回指向v中首元素的迭代器，其中<code>*begin=front</code></li><li><code>v.end()</code>：返回指向v中尾元素的迭代器，其中<code>*end=back</code></li></ul><p><strong>5.长度和容量</strong></p><ul><li><code>v.empty()</code>：若v为空返回<code>true</code>，非空返回<code>false</code></li><li><code>v.size()</code>：返回v的元素个数（长度）</li><li><code>v.resize()</code>：改变v的长度</li></ul><p><strong>6.容器的遍历</strong></p><p>以下才是我们经常写的玩意</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//1.最常用的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;v.<span class="hljs-built_in">size</span>();i++)&#123;<br>    cout&lt;&lt;v[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//2.利用迭代器</span><br><span class="hljs-keyword">for</span>(vector&lt;<span class="hljs-keyword">int</span>&gt;::iterator it=v.<span class="hljs-built_in">begin</span>();it&lt;v.<span class="hljs-built_in">end</span>();it++)&#123;<br>    cout&lt;&lt;*it&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="二、双端队列Deque"><a href="#二、双端队列Deque" class="headerlink" title="二、双端队列Deque"></a>二、双端队列Deque</h3><blockquote><p><code>std::deque</code>是STL提供的双端队列数据结构。</p><p><code>vector</code>对于头部的插入删除效率低，数据量越大，效率越低；<code>deque</code>相对而言，对头部的插入删除速度回比<code>vector</code>快</p><p><code>vector</code>访问元素时的速度会比<code>deque</code>快,这和两者内部实现有关</p></blockquote><h4 id="Deque的优良特性"><a href="#Deque的优良特性" class="headerlink" title="Deque的优良特性"></a>Deque的优良特性</h4><ul><li>随机访问的时间复杂度为常数$O(1)$</li><li>在结尾或起始插入或移除元素的时间复杂度均为常数$O(1)$</li><li>插入或溢出元素的时间复杂度同vector一样为线性$O(n)$</li></ul><h4 id="Deque使用方法"><a href="#Deque使用方法" class="headerlink" title="Deque使用方法"></a>Deque使用方法</h4><p>1.<strong>构造函数</strong></p><p>为了可以使用deque，请在你的头文件中包含<code>#include&lt;deque&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// deque的构造函数基本同vector相同，下面只列出最常用的一种</span><br>deque&lt;T&gt; d;<br>...<br></code></pre></div></td></tr></table></figure><p><strong>2.元素的增删改</strong></p><ul><li><code>d.push_back(element)</code>：在尾部插入元素element</li><li><code>d.push_front(element)</code>：在头部插入元素element</li><li><code>d.pop_back()</code>：在尾部删除一个元素</li><li><code>d.pop_front()</code>：在头部删除一个元素</li><li><code>d.insert(pos,n,element)</code>：在pos位置前增加n个相同的元素element，n可省略不写，默认添加一个</li><li><code>d.erase(begin,end)</code>：删除d中<code>[begin,end)</code>范围内的所有元素</li><li><code>d.clear()</code>：清除所有元素</li></ul><p><strong>3.元素的访问</strong></p><ul><li><code>d.at(pos)</code>：返回d中pos位置的引用</li><li><code>d.front()</code>：返回d中首元素的引用</li><li><code>d.back()</code>：返回d中尾元素的引用</li><li><code>d[pos]</code>：访问d中pos位置的值</li></ul><p><strong>4.长度和容量</strong></p><ul><li><code>d.empty()</code>：若d为空返回<code>true</code>，非空返回<code>false</code></li><li><code>d.size()</code>：返回d的元素个数（长度）</li><li><code>d.resize()</code>：改变d的长度</li></ul><p><strong>5.容器的遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//1.最常用的</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;d.<span class="hljs-built_in">size</span>();i++)&#123;<br>    cout&lt;&lt;d[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//2.利用迭代器</span><br><span class="hljs-keyword">for</span>(deque&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator it=d.<span class="hljs-built_in">begin</span>();it!=d.<span class="hljs-built_in">end</span>();it++)&#123;<br>    cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-comment">//3.通过at方式访问元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;d.<span class="hljs-built_in">size</span>();i++)&#123;<br>    cout&lt;&lt;d.<span class="hljs-built_in">at</span>(i)&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="三、双向链表List"><a href="#三、双向链表List" class="headerlink" title="三、双向链表List"></a>三、双向链表List</h3><blockquote><p><code>std::list</code> 是 STL 提供的<strong>双向链表</strong>数据结构。能够提供线性复杂度的随机访问，以及常数复杂度的插入和删除。</p><p><code>list</code> 的使用方法与 <code>deque</code> 基本相同，但是由于<code>list</code>本质是链表，不允许人们随机访问它，所以它与<code>deque</code>增删操作和访问的复杂度不同。</p><p><code>list</code> 的迭代器、长度、元素增删及修改相关的函数与 <code>deque</code> 相同，因此不作详细介绍。</p></blockquote><h4 id="List使用方法"><a href="#List使用方法" class="headerlink" title="List使用方法"></a>List使用方法</h4><p>由于链表的特性，若想访问中间元素，必须使用迭代器才能进行（不能随机访问），常用的两个元素访问函数如下：</p><ul><li><code>l.front()</code>：访问第一个元素</li><li><code>l.back()</code>：访问最后一个元素</li></ul><h3 id="四、关联式容器Set"><a href="#四、关联式容器Set" class="headerlink" title="四、关联式容器Set"></a>四、关联式容器Set</h3><blockquote><p><code>std::set</code>是STL提供的一种关联式容器，所有元素都会在插入时自动被排序。</p><p><code>set</code>和数学概念中的集合含义相同，不允许容器中存在相同元素，若将要插入的元素在集合中存在，则无法插入。</p><p><code>set</code> 内部采用红黑树实现。平衡二叉树的特性使得 <code>set</code> 非常适合处理需要同时兼顾查找、插入与删除的情况，因为它的搜索、移除和插入均为对数复杂度$O(logn)$。</p></blockquote><h4 id="Set的优良特性"><a href="#Set的优良特性" class="headerlink" title="Set的优良特性"></a>Set的优良特性</h4><ul><li>增删改查的时间复杂度非常优秀，均为对数级，懂自懂</li><li>自动进行排序和查重操作，省了很多麻烦</li></ul><h4 id="Set使用方法"><a href="#Set使用方法" class="headerlink" title="Set使用方法"></a>Set使用方法</h4><p>为了可以使用<code>set/muliset</code>，请在你的头文件中包含<code>#include&lt;set&gt;</code></p><p><strong>1.元素的增删改</strong></p><ul><li><code>s.insert(element)</code>：当s中没有element时，将该元素插入set中</li><li><code>s.erase(element)</code>：删除值为element的所有元素，并返回删除元素的个数</li><li><code>s.erase(pos)</code>：删除迭代器为 pos 的元素，要求迭代器必须合法</li><li><code>s.erase(begin,end)</code>：删除s中<code>[begin,end)</code>范围内的所有元素</li><li><code>s.clear()</code>：清空集合</li></ul><p><strong>2.元素的查找和统计</strong></p><ul><li><code>s.count(element)</code>：统计s中元素值为element的个数，在set中该值为0或1</li><li><code>s.find(element)</code>：若s中存在element会返回该元素的迭代器，否则返回 <code>end()</code></li><li><code>empty()</code> 返回容器是否为空</li><li><code>size()</code> 返回容器内元素个数</li></ul><p><strong>3.set指定排序规则</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//由于set默认在插入元素时将元素从小到大排序，若想不遵循此排列方式需要自定义排序规则</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCompare</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1,<span class="hljs-keyword">int</span> v2)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> v1&gt;v2;<br>    &#125;<br>&#125;;<br>set&lt;<span class="hljs-keyword">int</span>&gt;s1;<span class="hljs-comment">//默认排序方式，从小到大</span><br>set&lt;<span class="hljs-keyword">int</span>,MyCompare&gt;s2;<span class="hljs-comment">////自定义排序方式，从大到小</span><br></code></pre></div></td></tr></table></figure><h4 id="Mulitset"><a href="#Mulitset" class="headerlink" title="Mulitset"></a>Mulitset</h4><blockquote><p><code>mulitset</code>也存在于头文件<code>set</code>中</p><p>唯一与set不同的是，set不允许容器中有重复的元素，而multiset允许容器中有重复的元素</p></blockquote><h3 id="五、Pair"><a href="#五、Pair" class="headerlink" title="五、Pair"></a>五、Pair</h3><blockquote><p><code>std::pair</code> 是标准库中定义的一个类模板。用于将两个变量关联在一起，组成一个“对”，而且两个变量的数据类型可以是不同的。</p><p>当你需要返回成对出现的数据时，可能要用到pair嗷</p></blockquote><h4 id="Pair使用方法"><a href="#Pair使用方法" class="headerlink" title="Pair使用方法"></a>Pair使用方法</h4><ul><li><code>p.first</code>：访问pair的第一个数据（key），该元素起到索引作用</li><li><code>p.second</code>：访问pair的第二个数据（value）</li></ul><h4 id="Pair创建方法"><a href="#Pair创建方法" class="headerlink" title="Pair创建方法"></a>Pair创建方法</h4><p>pair的创建不需要头文件，以下是pair创建的两种方法</p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 )</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 )</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// 对这两种方法进行实例化演示</span><br>pair&lt;string,<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">p</span>(<span class="hljs-string">&quot;Tom&quot;</span>,<span class="hljs-number">20</span>);<br>cout&lt;&lt;<span class="hljs-string">&quot;name : &quot;</span>&lt;&lt;p.first&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;age : &quot;</span>&lt;&lt;p.second&lt;&lt;endl;<br><span class="hljs-comment">//第二种方式</span><br>pair&lt;string,<span class="hljs-keyword">int</span>&gt;p2=<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;Jerry&quot;</span>,<span class="hljs-number">30</span>);<br>cout&lt;&lt;<span class="hljs-string">&quot;name : &quot;</span>&lt;&lt;p2.first&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-string">&quot;age : &quot;</span>&lt;&lt;p2.second&lt;&lt;endl;<br></code></pre></div></td></tr></table></figure><h3 id="六、有序键值对容器Map"><a href="#六、有序键值对容器Map" class="headerlink" title="六、有序键值对容器Map"></a>六、有序键值对容器Map</h3><blockquote><p><code>std::map</code>中的所有元素都是<code>pair</code>，所有元素都会根据元素的键值自动排序</p><p><code>map</code> 内部采用红黑树实现，红黑树的好处懂自懂</p><p>如果你需要存储一些键值对，那就可以考虑使用<code>map</code></p></blockquote><h4 id="Map的优良特性"><a href="#Map的优良特性" class="headerlink" title="Map的优良特性"></a>Map的优良特性</h4><ul><li>一对一处理数据提供了便捷</li><li>map内部已进行自动排序</li></ul><h4 id="Map使用方法"><a href="#Map使用方法" class="headerlink" title="Map使用方法"></a>Map使用方法</h4><p><strong>1.构造函数</strong></p><p>为了可以使用map，请在你的头文件中包含<code>#include&lt;map&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; m; <span class="hljs-comment">//创建pair类型为&lt;int,int&gt;的map</span><br>map&lt;T1,T2&gt; m;<span class="hljs-comment">//创建pair类型为&lt;T1,T2&gt;的map</span><br>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;<span class="hljs-built_in">m2</span>(m);<span class="hljs-comment">//拷贝构造m2</span><br>map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;m3=m;<span class="hljs-comment">//赋值构造m3</span><br></code></pre></div></td></tr></table></figure><p><strong>2.元素的增删改</strong></p><ul><li><code>m.insert(pair&lt;T,T&gt;)</code>：在容器中插入元素</li><li><code>m.erase(key)</code>：删除容器中值为key的元素</li><li><code>m.erase(pos)</code>：删除pos迭代器所指的元素，返回下一个元素的迭代器</li><li><code>m.erase(begin,end)</code>：删除m中<code>[begin,end)</code>范围内的所有元素，返回下一个元素的迭代器</li><li><code>m.clear()</code>：清空map</li></ul><p><strong>3.元素的查找和统计</strong></p><ul><li><code>m.count(key)</code>：统计key的元素个数，返回非0及1</li><li><code>m.find(key)</code>：查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回end()</li><li><code>m.empty()</code> 返回容器是否为空</li><li><code>m.size()</code> 返回容器内元素个数</li></ul><h4 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h4><p>map和multimap区别：</p><p>map不允许容器中有重复key值元素，multimap允许容器中有重复key值元素</p><h3 id="七、栈Stack"><a href="#七、栈Stack" class="headerlink" title="七、栈Stack"></a>七、栈Stack</h3><blockquote><p><code>std::stack</code>是STL提供的一种后进先出（LIFO）的容器适配器，仅支持查询或删除最后一个加入的元素（栈顶元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。</p></blockquote><h4 id="Stack使用方法"><a href="#Stack使用方法" class="headerlink" title="Stack使用方法"></a>Stack使用方法</h4><p><strong>1.构造方法</strong></p><p>为了可以使用stack，请在你的头文件中包含<code>#include&lt;stack&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">stack&lt;T&gt; s;<br></code></pre></div></td></tr></table></figure><p><strong>2.常用函数</strong></p><ul><li><code>top()</code> 访问栈顶元素（如果栈为空，此处会出错）</li><li><code>push(x)</code> 向栈中插入元素 x</li><li><code>pop()</code> 删除栈顶元素</li><li><code>size()</code> 查询容器中的元素数量</li><li><code>empty()</code> 询问容器是否为空</li></ul><h3 id="八、队列Queue"><a href="#八、队列Queue" class="headerlink" title="八、队列Queue"></a>八、队列Queue</h3><blockquote><p><code>std::queue</code>是STL提供的一种先进先出（FIFO）的容器适配器，仅支持查询或删除第一个加入的元素（队首元素），不支持随机访问，且为了保证数据的严格有序性，不支持迭代器。</p></blockquote><p><strong>1.构造方法</strong></p><p>为了可以使用queue，请在你的头文件中包含<code>#include&lt;queue&gt;</code></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue&lt;T&gt; s;<br></code></pre></div></td></tr></table></figure><p><strong>2.常用函数</strong></p><ul><li><code>front()</code> 访问队首元素（如果队列为空，此处会出错）</li><li><code>push(x)</code> 向队列中插入元素 x</li><li><code>pop()</code> 删除队首元素</li><li><code>size()</code> 查询容器中的元素数量</li><li><code>empty()</code> 询问容器是否为空</li></ul><h2 id="算法algorithm"><a href="#算法algorithm" class="headerlink" title="算法algorithm"></a>算法algorithm</h2><blockquote><p>STL提供了非常多的实现算法的模板函数（查找、排序、操作），本版块将只介绍一些包含在<code>&lt;algorithm&gt;</code>常用的函数。完整的函数列表请单击链接：<a href="https://zh.cppreference.com/w/cpp/algorithm">戳我</a></p><p>友情提醒：aogorithm函数的范围定义为 <code>[first, last)</code> ，其中 <code>last</code> 指代要查询或修改的最后元素的<em>后一个</em>元素。</p></blockquote><h3 id="一、排序Sort"><a href="#一、排序Sort" class="headerlink" title="一、排序Sort"></a>一、排序Sort</h3><blockquote><p><code>sort()</code>作为<code>algorithm</code>中最常用（自认为）的模板函数，在竞赛中若无特殊要求一般都会使用该函数对序列进行排序操作，时间复杂度达到$O(nlogn)$，很秀</p></blockquote><p><strong>sort使用方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">( RandomIt first, RandomIt last, Compare comp )</span></span>;<br></code></pre></div></td></tr></table></figure><p>函数中有三个参数，分别为<code>first</code>,<code>last</code>,<code>comp</code>.</p><p>使用sort后以不降序排序范围 <code>[first, last)</code> 中的元素。不保证维持相等元素的顺序，若不自定义<code>comp</code>则默认为<code>less&lt;T&gt;()</code>，即从小到大排序，也可以写入<code>greater&lt;T&gt;()</code>，使得从大到小排序。</p><p>如果看上面的这些不太直观，下面给出一些实例化的使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">10</span>);<span class="hljs-comment">//代表从a[0]到a[9]</span><br><span class="hljs-built_in">sort</span>(a+j+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<span class="hljs-comment">//代表从a[j]到a[n]</span><br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">10</span>,less&lt;<span class="hljs-keyword">int</span> &gt;());<span class="hljs-comment">//实现了从小到大，less可以不写</span><br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">10</span>,greater&lt;<span class="hljs-keyword">int</span> &gt;());<span class="hljs-comment">//实现了从大到小</span><br><br><span class="hljs-comment">////////使用结构体排序的例子////////</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lizi</span>&#123;</span><br>  <span class="hljs-keyword">int</span> begin;<br>  <span class="hljs-keyword">int</span> end;<br>&#125;<br>lizi m[maxn];<br><span class="hljs-comment">//实现了对m数组的以end从小到大排序</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">comp</span><span class="hljs-params">(lizi a,lizi b)</span></span>&#123;<br>  <span class="hljs-keyword">return</span> a.end&lt;b.end;<br>&#125;<br><span class="hljs-comment">//主函数里</span><br><span class="hljs-built_in">sort</span>(m,m+maxn,comp);<span class="hljs-comment">//用comp的比较方法进行排序</span><br></code></pre></div></td></tr></table></figure><h3 id="二、查找Find"><a href="#二、查找Find" class="headerlink" title="二、查找Find"></a>二、查找Find</h3><ul><li><code>find</code>：顺序查找。<code>find(v.begin(), v.end(), value)</code>，其中 <code>value</code> 为需要查找的值</li><li><code>find_end</code>：逆序查找。<code>find_end(v.begin(), v.end(), value)</code></li><li><code>binary_search</code>：二分查找。<code>binary_search(v.begin(), v.end(), value)</code>，其中 <code>value</code> 为需要查找的值</li><li><code>lower_bound</code>：在一个有序序列中进行二分查找，返回指向第一个 <strong>大于等于</strong> 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。<code>lower_bound(v.begin(),v.end(),x)</code></li><li><code>upper_bound</code>：在一个有序序列中进行二分查找，返回指向第一个 <strong>大于</strong> 的元素的位置的迭代器。如果不存在这样的元素，则返回尾迭代器。<code>upper_bound(v.begin(),v.end(),x)</code></li></ul><h3 id="三、操作Operation"><a href="#三、操作Operation" class="headerlink" title="三、操作Operation"></a>三、操作Operation</h3><ul><li><p><code>reverse</code>：翻转数组、字符串。<code>reverse(v.begin(), v.end())</code> 或 <code>reverse(a + begin, a + end)</code></p></li><li><p><code>unique</code>：去除容器中相邻的重复元素。<code>unique(ForwardIterator first, ForwardIterator last)</code>，返回值为指向 <strong>去重后</strong> 容器结尾的迭代器，原容器大小不变。与 <code>sort</code> 结合使用可以实现完整容器去重</p></li><li><p><code>random_shuffle</code>：随机地打乱数组。<code>random_shuffle(v.begin(), v.end())</code> 或 <code>random_shuffle(v + begin, v + end)</code></p></li><li><p><code>next_permutation</code>：将当前排列更改为 <strong>全排列中的下一个排列</strong>。如果当前排列已经是 <strong>全排列中的最后一个排列</strong>（元素完全从大到小排列），函数返回 <code>false</code> 并将排列更改为 <strong>全排列中的第一个排列</strong>（元素完全从小到大排列）；否则，函数返回 <code>true</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论与数学</title>
      <link href="/2021/08/03/Number-Theory/"/>
      <url>/2021/08/03/Number-Theory/</url>
      
        <content type="html"><![CDATA[<p>数学和数论是程序设计竞赛中的一个重要组成部分，本文重点介绍了部分比较重要的数学与数论知识。</p><span id="more"></span><h1 id="数论板块"><a href="#数论板块" class="headerlink" title="数论板块"></a>数论板块</h1><h2 id="1-裴蜀引理"><a href="#1-裴蜀引理" class="headerlink" title="1. 裴蜀引理"></a>1. 裴蜀引理</h2><p>预备知识：</p><ul><li>约数和倍数: 如果一个整数$a$能够被正整数$b$整除，则存在另一个整数$p$使得$a = b \times p$或者$a / b = p$。称$b$是$a$的<code>约数</code>或<code>因数</code>，$a$是$b$的<code>倍数</code>。<br>正整数$a$的两个倍数的和或者差仍然是$a$的倍数。</li><li>公约数和最大公约数: 如果正整数$p$同时是两个整数$a，b$的约数，称$p$为$a$和$b$的公约数，$a$和$b$所有公约数中最大的数称为<code>最大公约数</code>。<br>$0$是所有数的倍数。所有的正整数都是$0$的约数。</li><li>带余除法: 给定一个整数$a$和一个整数$q$，总能找到一个整数$b$使得$a = bq + r$，其中$0 \leq r &lt; q$，称$r$为$a$被$q$除的余数。<br>总能的证明: 画数轴，$q$为单位，$a − r$总能落在数轴上</li><li>素数: 一个大于$1$的正整数，如果只有$1$和它本身两个约数，就称它为<code>素数</code>。<br>  两个整数的最大公约数如果为$1$，则称这两个数互素。</li></ul><p><strong>裴蜀引理：</strong> 给定两个整数$a$和$b$，假设他们的最大公约数是$p$，当且仅当$n$是$p$的倍数时，下列方程$(x, y)$有整数解:</p><script type="math/tex; mode=display">ax + by = n</script><p>证明：</p><p>(1) 若$b=0$，则$(a,b)=a$. 这时定理显然成立。</p><p>(2) 若$a,b$不等于$0$：</p><p>记$d = (a, b)$, 对$ax + by = d$，两边同时除以$d$，可得$a_1x + b_1y = 1$，其中$(a_1,b_1) = 1$。</p><p>转证$a_1x + b_1y = 1$。由带余除法:</p><script type="math/tex; mode=display">a_1 = q_1b_1 + r_1, 0 < r_1 < b_1 \tag{1}</script><script type="math/tex; mode=display">b_1 = q_2r_1 + r_2, 0 < r_2 < r_1 \tag{2}</script><script type="math/tex; mode=display">r_1 = q_3r_2 + r_3, 0 < r_3 < r_2 \tag{3}</script><script type="math/tex; mode=display">\cdots</script><script type="math/tex; mode=display">r_{n-4} = q_{n-2}r_{n-3} + r_{n-2} \tag{4}</script><script type="math/tex; mode=display">r_{n-3} = q_{n-1}r_{n-2} + r_{n-1} \tag{5}</script><script type="math/tex; mode=display">r_{n-2} = q_{n}r_{n-1} + r_{n} \tag{6}</script><script type="math/tex; mode=display">r_{n-1} = q_{n+1}r_{n} + 1 \tag{7}</script><p>所以，由$(7)$和$(6)$推出</p><script type="math/tex; mode=display">r_{n-2}A_n-2 + r_{n-1}B_n-1 = 1</script><p>再结合$(5)$推出</p><script type="math/tex; mode=display">r_{n-3}A_n-3 + r_{n-2}B_n-2 = 1</script><p>再结合$(4)$推出</p><script type="math/tex; mode=display">r_{n-4}A_n-4 + r_{n-3}B_n-3 = 1</script><script type="math/tex; mode=display">\cdots</script><p>再结合$(3)$推出</p><script type="math/tex; mode=display">r_1A_1 + r_2B_2 = 1</script><p>再结合$(2)$推出</p><script type="math/tex; mode=display">b_1A_0 + r_1B_0 = 1</script><p>再结合$(1)$推出</p><script type="math/tex; mode=display">a_1x + b_1y = 1</script><p>证明完毕。</p><p><strong>推论</strong></p><ul><li>当且仅当下面方程$(x, y)$有整数解时，两个整数$a$和$b$互素：<script type="math/tex; mode=display">ax + by = 1</script></li><li>如果素数$p$整除两个整数$a$和$b$的乘积$ab$，则$p$必然会整除$a$或$b$</li></ul><h2 id="2-辗转相除法"><a href="#2-辗转相除法" class="headerlink" title="2. 辗转相除法"></a>2. 辗转相除法</h2><p>辗转相除法是求两个数的最大公约数的算法。</p><p>辗转相除法是求两个数的最大公约数的算法，对于$a, b(a &gt; b, a,b \ne 0)$而言，其有以下步骤:</p><ol><li>求$c = a \% b$</li><li>令$a = b, b = c$，重复步骤$(1)$</li><li>当$c=0$时，$b$为所求最大公约数</li></ol><p>使用辗转相除法时，其步骤如下，以求$82$和$24$的最大公约数为例：</p><script type="math/tex; mode=display">\begin{matrix}    a &  &  &  &  b &  & c\\    82 & = & 3 & \times & 24 & + & 10 \\    24 & = & 2 & \times & 10 & + & 4 \\    10 & = & 2 & \times & 4 & + & 2 \\    4 & = & 2 & \times & 2 & + & 0 \\\end{matrix}</script><p>此时求得$82$和$24$的最大公约数为$2$。</p><p>辗转相除法(欧几里得算法)的<code>C++</code>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: 欧几里得算法的递归实现</span><br><span class="hljs-comment"> * @param &#123;int&#125; a 求最大公约数的某数</span><br><span class="hljs-comment"> * @param &#123;int&#125; b 求最大公约数的某数</span><br><span class="hljs-comment"> * @return &#123;int&#125; 求得的最大公约数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: 欧几里得算法的循环实现</span><br><span class="hljs-comment"> * @param &#123;int&#125; a 求最大公约数的某数</span><br><span class="hljs-comment"> * @param &#123;int&#125; b 求最大公约数的某数</span><br><span class="hljs-comment"> * @return &#123;int&#125; 求得的最大公约数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> c = a % b;<br>    <span class="hljs-keyword">while</span> (c != <span class="hljs-number">0</span>) <br>    &#123;<br>        a = b;<br>        b = c;<br>        c = a % b; <br>    &#125;<br>    <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="3-算术基本定理"><a href="#3-算术基本定理" class="headerlink" title="3. 算术基本定理"></a>3. 算术基本定理</h2><p><strong>算术基本定理：</strong> 如果不考虑排列次序的话，每个大于1的自然数都只能有一种方式分解成若干个素数的乘积。</p><p>可以理解为：</p><ul><li><strong>存在性：</strong> 每个大于$1$的自然数都可以分解成素数的乘积</li><li><strong>唯一性：</strong> 这种分解不考虑次序排列的意义下是唯一的</li></ul><p>证明：</p><p>若$n$是素数，则$n = n$。若$n$是合数，则$n = n_1 \times n_2$，对$n_1, n_2$重复上过程，可得$n = n_p \times \cdots \times n_q, n_i \in 素数集$。</p><p>则任意$n &gt; 1$，均可以分解成素数的乘积，证得存在性。</p><p>设</p><script type="math/tex; mode=display">\begin{aligned}    n &= p_1 \times p_2 \times p_3 \times \cdots \times p_s \\    &= q_1 \times q_2 \times q_3 \times \cdots \times q_t\end{aligned}</script><p>则$n \% p_1 = 0$，即$q_1 \times q_2 \times q_3 \times  \cdots \times q_t \% p_1 = 0$。</p><p>又$p_i, q_i \in 素数集$，则当$p_i \ne q_i$时，$p_i \% q_i \ne 0$。</p><p>所以必定有$q_i = p_1$，才能使得$q_1 \times q_2 \times q_3 \times  \cdots \times q_t \% p_1 = 0$。</p><p>令$n = n \div q_i = n \div p_1$，重复上述过程，可以得知对于任意$p_x$，必然有一个$q_y$与之对应。</p><p>所以必然有一种排列使得$p_i = q_i$，即在不考虑排列的情况下，这种分解是唯一的，唯一性得证。</p><p>证明完毕。</p><h2 id="4-最大公约数与最小公倍数的关系"><a href="#4-最大公约数与最小公倍数的关系" class="headerlink" title="4. 最大公约数与最小公倍数的关系"></a>4. 最大公约数与最小公倍数的关系</h2><p>如果正整数$p$同时是两个整数$a，b$的约数，称$p$为$a$和$b$的公约数，$a$和$b$所有公约数中最大的数称为最大公约数，记作$(a,b)$。</p><p>如果正整数$p$同时是两个整数$a, b$的倍数，称$p$为$a$和$b$的公倍数，$a$和$b$所有公倍数中最小的数称最小公倍数，记作$[a, b]$。</p><p><strong>最大公约数与最小公倍数的关系：</strong> 对于任意的正整数$a, b$，其最大公约数与最小公倍数满足下述关系：</p><script type="math/tex; mode=display">a \times b = (a, b) \times [a, b]</script><p>证明：</p><p>若$a, b$中某数等于$1$，满足上述关系。</p><p>已知任意大于一的整数都可以表示为若干个素数的乘积，则对于$a, b$：</p><script type="math/tex; mode=display">\begin{aligned}    a &= p_1^{s_1} \times p_2^{s_2} \times \cdots \times p_n^{s_n} \\    b &= p_1^{t_1} \times p_2^{t_2} \times \cdots \times p_n^{t_n}\end{aligned}</script><p>其中$p_i \in 素数集$，所以$a, b$的最大公约数可以表示为：</p><script type="math/tex; mode=display">(a, b) = p_1^{\min(s_1, t_1)} \times p_2^{\min(s_2, t_2)} \times \cdots \times p_n^{\min(s_n, t_n)}</script><p>$a, b$的最小公倍数可以表示为：</p><script type="math/tex; mode=display">[a, b] = p_1^{\max(s_1, t_1)} \times p_2^{\max(s_2, t_2)} \times \cdots \times p_n^{\max(s_n, t_n)}</script><p>而对于任意$p_i^{s_i}, p_i^{t_i}$，都有$p_i^{s_i} \times p_i^{t_i} = p_i^{\min(s_i, t_i)} \times p_i^{\max(s_i, t_i)}$恒成立。</p><p>则有：</p><script type="math/tex; mode=display">\begin{aligned}    a \times b &= p_1^{s_1} \times p_1^{t_1} \times p_2^{s_2} \times p_2^{t_2} \times \cdots \times p_n^{s_n} \times p_n^{t_n} \\    &= p_1^{\min(s_1, t_1)} \times p_1^{\max(s_1, t_1)} \times p_2^{\min(s_2, t_2)} \times p_2^{\max(s_2, t_2)} \times \cdots \times p_n^{\min(s_n, t_n)} \times p_n^{\max(s_n, t_n)} \\    &= (a, b) \times [a, b]\end{aligned}</script><p>证明完毕。</p><h2 id="5-素数"><a href="#5-素数" class="headerlink" title="5. 素数"></a>5. 素数</h2><h3 id="5-0-n-以内的素数有几个"><a href="#5-0-n-以内的素数有几个" class="headerlink" title="5.0 $n$以内的素数有几个"></a>5.0 $n$以内的素数有几个</h3><p><strong>素数计算函数：</strong></p><p>小于或等于$x$的素数的个数，可以用$\pi(x)$表示，有：</p><script type="math/tex; mode=display">\lim_{x \to \infty} {\pi(x)} = \frac{x}{\ln{x}}</script><p>在$x \geq 10^5$时，此函数的误差已经小于$1\%$了。通常情况下，可以用此函数估计素数的个数。</p><h3 id="5-1-如何判断素数"><a href="#5-1-如何判断素数" class="headerlink" title="5.1 如何判断素数"></a>5.1 如何判断素数</h3><p><strong>$O(n)$复杂度算法：</strong></p><p>判断一个大于$2$的整数$n$是否为素数，最简单的方法便是根据素数的定义去判断，即使用从$2$到$n$之间的所有整数与$n$做除法，看能否与$n$整除，其代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i)<br>&#123;<br><span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) <br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>$O(\sqrt{n})$复杂度算法：</strong></p><p>在上面的算法中，其实并不需要按照定义一直判断到$n$，我们只需要判断从$2$到$\sqrt{n}$之间的整数就可以了。</p><p>证明：</p><p>若$n$不是素数，则其可以表示为$n = n_1 \times n_2$，我们不妨令$n_1 \leq n_2$。</p><p>此时我们知道$n_1$可能取得最大值时，有$\max(n_1) = n \div \min(n_2)$，即$n_1 = n_2$，此时$n_1 = n \div n_2 = \sqrt{n}$。</p><p>所以$n_1 \in [2, \sqrt{n}]$，即若$n$不是素数，其必有一个因数在区间$[2, \sqrt{n}]$。</p><p>证明完毕。</p><p>其代码实现较上文差别不大，此处就不单独展示了。</p><p><strong>(选学)Fermat素性测试：</strong></p><p>我们可以根据<code>费马小定理</code>得出一种检验素数的思路：</p><p>不断地选取在$[2, n-1]$中的基$a$，并检验是否每次都有$a^{n-1} \equiv 1 \pmod n$ </p><p>其<code>C++</code>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: 费马素性测试</span><br><span class="hljs-comment"> * @param &#123;int&#125; n 要判断的数n</span><br><span class="hljs-comment"> * @return &#123;bool&#125; n是否为素数，是则返回true</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">millerRabin</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>) <br>    &#123;<br>        <span class="hljs-keyword">return</span> n == <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// test_time为测试次数,建议设为不小于8的整数以保证正确率,但也不宜过大,否则会影响效率</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= test_time; ++i) <br>    &#123;<br>        <span class="hljs-keyword">int</span> a = <span class="hljs-built_in">rand</span>() % (n - <span class="hljs-number">2</span>) + <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">quickPow</span>(a, n - <span class="hljs-number">1</span>, n) != <span class="hljs-number">1</span>) <br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>但是费马小定理的逆定理并不成立，这个方法也不是完全准确的，需要额外考虑<code>Carmichael Number</code>。这个方法的时间复杂度大致为$O(\log n)$。</p><h3 id="5-2-如何生成素数"><a href="#5-2-如何生成素数" class="headerlink" title="5.2 如何生成素数"></a>5.2 如何生成素数</h3><p>在上面我们知道了如何判断一个数是不是素数，那么引申出了另一个问题，我们要如何求某个区间内的所有素数呢？</p><p>我们当然可以按照上面的方法对区间内每一个数都进行一次判断，但我们稍作分析就知道，判断一个数是不是素数的时间复杂度是$O(\sqrt{n})$，那么判断$n$个数是不是素数的时间复杂度就是$O(n\log n)$，这其实是一个十分费时的算法，通常情况下会被比赛卡超时。</p><p>然后我们就要讲到我们的两大法宝： <code>埃拉托斯特尼筛法</code>和<code>线性筛法</code></p><p><strong>埃氏筛</strong></p><p>埃氏筛法的基本原理是：如果找到一个质数，那么这个质数的倍数都不是质数。</p><p>我们只需要将范围内的所有数从头开始并标记出他们的倍数，遇到标记过的数就跳过，直到标记到最后为止。其过程表示如下：</p><center><div aligned="center"><img src = "https://www.pianshen.com/images/522/fc4debb1d5aae09a985ee372829aed02.gif"/></div></center><p>这个过程的<code>C++</code>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// include &lt;cstdlib&gt;</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: 埃拉托斯特尼筛法</span><br><span class="hljs-comment"> * @param &#123;int&#125; n 要求的素数区间，即求[2, n]之间的素数</span><br><span class="hljs-comment"> * @return &#123;*&#125; isPrime为true的均为素数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EratosthenesMethod</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">bool</span> *tag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <br>    &#123;<br>        isPrime[i] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i * i &lt; n; ++i) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (isPrime[i]) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i * i; j &lt; n; j += i) <br>            &#123;<br>                isPrime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>上面的算法可以预先处理每个数都有的质因数以提升效率。其复杂度为$O(n \log \log n)$</p><p>想看其复杂度计算过程吗？</p><blockquote><p>参考自<a href="https://oi-wiki.org/math/sieve/">OI-Wiki.org</a></p></blockquote><p>可以直接观察知埃氏筛法的复杂度为</p><script type="math/tex; mode=display">n \sum_p {1 \over p}</script><p>调和级数$\displaystyle \sum_n {1 \over n} = \ln n$，由唯一分解定理可得：</p><script type="math/tex; mode=display">\sum_n {\frac{1}{n}} = \prod_{p} (1 + \frac{1}{p} + \frac{1}{p^2} + \cdots) = \prod_p {\frac{p}{p-1}}</script><p>两边同时取对数，得：</p><script type="math/tex; mode=display">\begin{aligned}    \ln \sum_n {\frac{1}{n}} &= \ln \prod_p {\frac{p}{p-1}} \\    \ln \ln n &= \sum_p ({\ln p - \ln (p-1)})\end{aligned}</script><p>易知$\displaystyle \int \frac{1}{x} dx = \ln x$，由微积分基本定理：</p><script type="math/tex; mode=display">\sum_p ({\ln p - \ln (p-1)}) = \sum_p {\int_{p-1}^{p} {\frac{1}{x}dx}}</script><p>得</p><script type="math/tex; mode=display">\int_{p-1}^{p} {\frac{1}{x}dx} > \frac{1}{p}</script><p>即</p><script type="math/tex; mode=display">\ln \ln n = \sum_p {\int_{p-1}^{p} {\frac{1}{x}dx}} > \sum_p {\frac{1}{p}}</script><p>用$O$法表示即为$O(n \log \log n)$</p><p><strong>线性筛</strong></p><p>埃氏筛法仍有优化空间，它会将一个合数重复多次标记。有没有什么办法省掉无意义的步骤呢？答案是肯定的。</p><p>如果能让每个合数都只被标记一次，那么时间复杂度就可以降到$O(n)$了。</p><p>其<code>C++</code>代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: 欧拉筛法</span><br><span class="hljs-comment"> * @param &#123;int&#125; n 要求的n以内的素数</span><br><span class="hljs-comment"> * @return &#123;void&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">EulerMethod</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *phi = <span class="hljs-keyword">new</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>[n];<br>phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) <br>&#123;<br><span class="hljs-keyword">if</span> (!vis[i])<br>&#123;<br>phi[i] = i - <span class="hljs-number">1</span>;<br>pri[cnt++] = i;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; ++j) <br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">1ll</span> * i * pri[j] &gt;= n) <span class="hljs-comment">// 此处1ll是在计算时使用long long类型，避免溢出</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>vis[i * pri[j]] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (i % pri[j]) <br>&#123;<br>phi[i * pri[j]] = phi[i] * (pri[j] - <span class="hljs-number">1</span>);<br>&#125; <br><span class="hljs-keyword">else</span> <br>&#123;<br>phi[i * pri[j]] = phi[i] * pri[j];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>(选学) <code>min_25</code>筛法</strong></p><p>这个筛法是<code>min_25</code>大佬在比赛的时候发明的筛法，其时间复杂度为$O(n^{2 \over 3})$，其中很多内容<del>我们也不会</del>需要同学们自己理解</p><blockquote><p>本节参考了大量资料：</p><ul><li><a href="https://\min-25.hatenablog.com/entry/2018/11/11/172216">Sum of Multiplicative Function - min_25</a></li><li><a href="https://www.cnblogs.com/zhoushuyu/p/9187319.html">min_25筛 - 租酥雨</a></li><li><a href="https://blog.csdn.net/baiyifeifei/article/details/90454317">min25筛学习笔记&amp;模板详解 - Flyppy_White</a></li></ul></blockquote><p>首先我们定义一些符号和说明：</p><ul><li>$p \in \mathbb{R}$并且$p \in 素数集$，$p_k$是所有素数中第$k$小的素数，特别定义$p_0 = 1$</li><li>$\operatorname{lpf}(n)$表示$n$最小的质因数，特别定义$\operatorname{lpf}(1) = 1$</li><li>$f(p)$是一个关于$p$的项数较少的多项式或者可以快速求值的多项式，$f(p^c)$需要能够快速求值</li><li>$\displaystyle x / y = \left\lfloor \frac{x}{y} \right\rfloor$</li><li>$\displaystyle F<em>k(n) = \sum^{n}</em>{i=2} {[p_k \leq \operatorname{lpf(i)}] f(i)}$</li></ul><p>我们不难知道，通过枚举每个$i$的最小质因子及其次数可以得到$F_k(n)$的递推式</p><script type="math/tex; mode=display">\begin{aligned}     F_{k}(n) &= \sum_{i = 2}^{n} [p_{k} \le \operatorname{lpf}(i)] f(i) \\     &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + \sum_{\substack{k \le i \\ p_{i} \le n}} f(p_{i}) \\     &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c} \le n}} f\left(p_{i}^{c}\right) ([c > 1] + F_{i + 1}\left(n / p_{i}^{c}\right)) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1}) \\     &= \sum_{\substack{k \le i \\ p_{i}^{2} \le n}} \sum_{\substack{c \ge 1 \\ p_{i}^{c + 1} \le n}} \left(f\left(p_{i}^{c}\right) F_{i + 1}\left(n / p_{i}^{c}\right) + f\left(p_{i}^{c + 1}\right)\right) + F_{\mathrm{prime}}(n) - F_{\mathrm{prime}}(p_{k - 1}) \end{aligned}</script><p>最后一步推导基于这样一个事实：</p><p>对于满足$p<em>{i}^{c} \le n &lt; p</em>{i}^{c + 1}$ 的 $c$，有：</p><script type="math/tex; mode=display">p_{i}^{c + 1} < n \iff n / p_{i}^{c} < p_{i} < p_{i + 1}</script><p>即</p><script type="math/tex; mode=display">F_{i + 1}\left(n / p_{i}^{c}\right) = 0</script><p>其<code>C++</code>实现，请转到<a href="https://blog.csdn.net/baiyifeifei/article/details/90454317">min25筛学习笔记&amp;模板详解 - Flyppy_White</a></p><h1 id="数学板块"><a href="#数学板块" class="headerlink" title="数学板块"></a>数学板块</h1><h2 id="1-矩阵快速幂"><a href="#1-矩阵快速幂" class="headerlink" title="1. 矩阵快速幂"></a>1. 矩阵快速幂</h2><h3 id="1-1-矩阵"><a href="#1-1-矩阵" class="headerlink" title="1.1 矩阵"></a>1.1 矩阵</h3><p>这一点回去找你们的线性代数老师。</p><p><del>需要的这里有一份线性代数笔记：<a href="https://sc-cos-1258290809.cos.ap-guangzhou.myqcloud.com/files/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0.pdf">线性代数 - sunist</a></del></p><h3 id="1-2-快速幂"><a href="#1-2-快速幂" class="headerlink" title="1.2 快速幂"></a>1.2 快速幂</h3><p>对于任意的数$n$，都可以通过位运算将它化为多个$2$的幂的和的形式。</p><p>例如:</p><script type="math/tex; mode=display">\begin{aligned}        100_{10} &= 1100100_{2}=2^2+2^5+2^6 \\     735_{10} &= 1011110001_2 = 2^0+2^4+2^5+2^6+2^7+2^9\end{aligned}</script><p>但是，当指数特别大的时候，如$n^{114514}$，我们想要计算它的时候，就得计算$114513$次乘法才能得出结果。这样我们就得等很久才能计算完毕，那么有没有什么办法能够加速这一过程呢？</p><p>亲亲，有的！这个方法就是快速幂：</p><p>以$n^{735}$为例：</p><script type="math/tex; mode=display">n^{735} = n^{2^0+2^4+2^5+2^6+2^7+2^9}=n^{2^0}+n^{2^4}+n^{2^5}+n^{2^6}+n^{2^7}+n^{2^9}  \tag{1}</script><p>同时，根据<del>常识</del> 常人所不知道的知识：</p><script type="math/tex; mode=display">2^n = 1 << n</script><p>我们知道其时间复杂度为$O(1)$，对于$(1)$式$2$的幂只需要$6$次位运算即可求得：</p><script type="math/tex; mode=display">2^0=1，2^4=16,2^5=32,2^6=64,2^7=128,2^8=256</script><p>即：</p><script type="math/tex; mode=display">n^{735} = n^{2^0+2^4+2^5+2^6+2^7+2^9}=n^1+n^{16}+n^{32}+n^{64}+n^{128}+n^{256}</script><p>我们再再依次求$n$的幂，求完相加次数就变为了$(1+16+32+64+128+256)$次乘法和$5$次加法，一共$502$次运算。但实际编程中后一次运算的结果可以由前一次运算的结果迭代而来。</p><p>即：</p><script type="math/tex; mode=display">n^1  \tag{1}</script><script type="math/tex; mode=display">n^2 = {(n^1)}^2</script><script type="math/tex; mode=display">n^4 = {(n^{2})}^2</script><script type="math/tex; mode=display">n^{8} = (n^4)^2</script><script type="math/tex; mode=display">n^{16} = {(n^{8})}^2 \tag{2}</script><script type="math/tex; mode=display">n^{32} = {(n^{16})}^2 \tag{3}</script><script type="math/tex; mode=display">n^{64} = {(n^{32})}^2 \tag{4}</script><script type="math/tex; mode=display">n^{128} = {(n^{64})}^2 \tag{5}</script><script type="math/tex; mode=display">n^{256} = {(n^{128})}^2 \tag{6}</script><p>由于位运算帮助我们计算是否该取该数，实际上运算次数是$8$次乘法运算、$5$次加法运算和$8$次位运算，一共$21$次。由$734$次运算降低为$21$次运算，效率上大大提高。这就是快速幂。</p><p>快速幂的<code>C++</code>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: 快速幂，计算base^index</span><br><span class="hljs-comment"> * @param &#123;int&#125; base 底数</span><br><span class="hljs-comment"> * @param &#123;int&#125; index 指数</span><br><span class="hljs-comment"> * @return &#123;int&#125; 计算结果base^index</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quick_power</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> base, <span class="hljs-keyword">int</span> index)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (index &amp; <span class="hljs-number">1</span>)<br>        &#123;<br>            result *= base;<br>        &#125;<br>        base *= base;<br>        index = index &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="1-3-矩阵快速幂"><a href="#1-3-矩阵快速幂" class="headerlink" title="1.3 矩阵快速幂"></a>1.3 矩阵快速幂</h3><p>现在我们已经知道了什么是矩阵，什么是快速幂。<del>聪明的同学们一定能很简单的推出什么是矩阵快速幂吧！</del></p><p>那么什么是矩阵快速幂呢？答案当然是矩阵的快速幂啦！</p><blockquote><p>下面为了叙述方便，我们使用方阵举例，矩阵也有同样的性质。</p></blockquote><p>对于一个方阵$A$,它的$n$次幂为：</p><script type="math/tex; mode=display">A^n=\prod_{i=1}^n{A}</script><p>对于$A^n$，需要做$n-1$次乘法运算。由整数快速幂的计算方法，你可能已经想到了，方阵也可以简化运算。没错，这就是矩阵快速幂。</p><p>如$A^{19}$:</p><script type="math/tex; mode=display">A^{19} = A^{16} + A^2 + A^1</script><p>同样后面的运算结果可以由前面的运算结果迭代而来:</p><script type="math/tex; mode=display">A^1</script><script type="math/tex; mode=display">A^2 = A^1 * A^1</script><script type="math/tex; mode=display">A^4 = A^2 * A^2</script><script type="math/tex; mode=display">A^8 = A^4 * A^4</script><script type="math/tex; mode=display">A^{16}=A^8*A^8</script><p>运算过程和整数快速幂相同，而两个矩阵的乘法运算<del>我们早就刻进DNA啦</del> 我们也能没什么难度地实现。</p><p>那么下面就是方阵快速幂的<code>C++</code>代码实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @description: 方阵快速幂</span><br><span class="hljs-comment"> * @param &#123;SquareMatrix&#125; A 快速幂的底，即方阵A</span><br><span class="hljs-comment"> * @param &#123;int&#125; n 指数</span><br><span class="hljs-comment"> * @return &#123;SquareMatrix&#125; 计算结果，即A^n</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">SquareMatrix <span class="hljs-title">matrix_quick_power</span><span class="hljs-params">(SquareMatrix A,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    SquareMatrix base = A;<br>    SquareMatrix result;<br>    <span class="hljs-comment">//对B进行初始化，初始化为单位阵</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; N;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; N;j++)&#123;<br>            <span class="hljs-keyword">if</span>(i == j)&#123;<br>                result.matrix[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                result.matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(n)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n&amp;<span class="hljs-number">1</span>)<br>        &#123;<br>            result = <span class="hljs-built_in">mul</span>(result,base);<br>        &#125;<br>        base = <span class="hljs-built_in">mul</span>(base,base);<br>        n = n&gt;&gt;<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>那么矩阵快速幂有什么用呢？<strong>请同学们转到<a href="https://oi-wiki.org/math/quick-pow/">快速幂</a>仔细阅读。</strong> <del>不是懒不写啊，已经加粗了，自己没看错过了后果自负。</del></p><h2 id="2-高精度计算"><a href="#2-高精度计算" class="headerlink" title="2. 高精度计算"></a>2. 高精度计算</h2><p>高精度计算(Arbitrary-Precision Arithmetic)，也被称作大整数(bignum)计算，运用了一些算法结构来支持更大整数间的运算(数字大小超过语言内建整型)。</p><p>此节难度较低，同学们仅需知道竖式是怎么算的就行了，模拟实现这些过程就完事了。</p><p><del>不会建议退学重读小学。</del></p><p>可以参考高精度的模版：<a href="https://oi-wiki.org/math/bignum/">高精度计算</a></p><h2 id="3-组合数学"><a href="#3-组合数学" class="headerlink" title="3. 组合数学"></a>3. 组合数学</h2><p>排列组合是组合数学中的基础。</p><ul><li>排列就是指从给定个数的元素中取出指定个数的元素进行排序</li><li>组合则是指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。</li></ul><p>排列组合的中心问题是研究给定要求的排列和组合可能出现的情况总数。排列组合与古典概率论关系密切。</p><p>在我们所有的暴力、枚举题目中，无遗漏地进行排列组合是我们解题的关键。</p><h3 id="3-1-排列组合"><a href="#3-1-排列组合" class="headerlink" title="3.1 排列组合"></a>3.1 排列组合</h3><p><code>加法原理</code>、<code>乘法原理</code>、<code>二项式定理</code>啥的如果不知道自己回去补课，此处重点介绍全排列。</p><p>什么是全排列呢？以$1,2,3$三个数(状态)为例，它们的全排列为：</p><script type="math/tex; mode=display">\begin{matrix}    1 & 2 & 3 \\    1 & 3 & 2 \\    2 & 1 & 3 \\    2 & 3 & 1 \\    3 & 1 & 2 \\    3 & 2 & 1\end{matrix}</script><p>对于$n$种状态的全排列而言，它们有$n!$种情况。</p><p>对于$1,2,3$而言，我们可以很轻松地写出对应的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printPermutation</span> <span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span>; ++i) <br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">3</span>; ++j) <br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">3</span>; ++k) <br>            &#123;<br>                <span class="hljs-keyword">if</span> (i == j || i == k || j == k) <br>                &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <br>                &#123;<br>                    <span class="hljs-built_in">print</span>(i, j, k);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>在状态数量较少的时候，我们可以使用循环来进行全排列，但是在状态较多的时候，循环就显得过于繁复，同时循环也无法处理状态数量未知的全排列。此时我们就应该考虑其他方法实现全排列了。</p><p><strong>递归实现：</strong></p><p>我们可以发现，全排列是把已知的所有状态按照不同的顺序分别展示出来，那么我们就不难想到我们可以使用图结构和深度优先搜索来实现这个需求，我们只需要从不同的节点出发，遍历有所有状态组成的图即可。</p><p>其<code>C++</code>实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">bool</span> *Visited, <span class="hljs-keyword">int</span> *answer)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt; n)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-built_in">print</span>(answer[i]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!Visited[i])<br>&#123;<br>answer[x<span class="hljs-number">-1</span>] = i+<span class="hljs-number">1</span>;<br>Visited[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-built_in">printPermutation</span>(x+<span class="hljs-number">1</span>, n, Visited, answer);<br>Visited[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当然，建立树并对树进行遍历也是可以实现的，更多的写法可以转到<a href="https://www.luogu.com.cn/problem/solution/P1706">P1706 全排列问题 题解 - 洛谷</a></p><p><strong>STL实现：</strong></p><p>在<code>C++ STL</code>中，有一个函数叫做全排列函数，它分为<code>next_permutation</code>和<code>prev_permutation</code>，作用是求当前排列的上一个排列和下一个排列。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">next_permutation</span><span class="hljs-params">(iterator start,iterator end)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">prev_permutation</span><span class="hljs-params">(iterator start,iterator end)</span></span>;<br></code></pre></div></td></tr></table></figure><p>其中<code>start</code>是排列状态的开始位置，<code>end</code>是排列状态的结束位置，返回值是能否找到下一个/上一个排列，能则返回<code>true</code>，不能则返回<code>false</code>。</p><p>同时，此函数的上一项、下一项按照字典序进行排列。</p><p>至于具体的使用方法，可以转到<a href="https://blog.csdn.net/ac_gibson/article/details/45308645">C++STL中全排列函数next_permutation的使用 - AC_Gibson</a></p><h3 id="3-2-容斥原理"><a href="#3-2-容斥原理" class="headerlink" title="3.2 容斥原理"></a>3.2 容斥原理</h3><p>我们先引入一个问题：</p><blockquote><p>假设班里有$11$个学生喜欢数学，$45$个学生喜欢语文，$14$个学生喜欢编程，班里至少喜欢一门学科的有多少个学生呢？</p><p>是$11+45+14 = 70$个吗？显然不是的，因为有些学生可能同时喜欢数学和语文，或者语文和编程，甚至还有可能三者都喜欢。</p></blockquote><p>对于上面的问题，其很有可能是下图这种情况：</p><center><div aligned="center"><img src="https://oi-wiki.org/math/images/incexcp.png"/></div></center><p>现在我们引入容斥原理。</p><p>设$U$种元素有$n$种不同的属性，而第$i$种属性称为$P_i$，拥有属性$P_i$的元素构成集合$S_i$，那么有：</p><script type="math/tex; mode=display">\begin{aligned}    \left| \bigcup_{i=1}^{n} S_i \right| &= \sum_{i} | S_i | - \sum_{i<j} | S_i \cap S_j | + \sum_{i<j<k} |S_i \cap S_j \cap S_k | - \cdots \\     & \quad + (-1)^{m-1} \sum_{a_i<a_{i+1} } \left| \bigcap_{i=1}^{m} S_{a_i} \right| + \cdots + (-1)^{n-1} \left| S_1 \cap \cdots \cap S_n \right|\end{aligned}</script><p>即：</p><script type="math/tex; mode=display">\left|\bigcup_{i=1}^{n}S_i\right|=\sum_{m=1}^n(-1)^{m-1}\sum_{a_i<a_{i+1} }\left|\bigcap_{i=1}^mS_{a_i}\right|</script><p><del>看懂了吗？是不是超级简单。</del> 上面的乱七八糟的公式其实就是在做一件事：</p><p>先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复。</p><p>这种原理在我们的程序设计中有着广泛的应用。</p><h2 id="4-概率论"><a href="#4-概率论" class="headerlink" title="4. 概率论"></a>4. 概率论</h2><p>这玩意主要以理论为主，与计算机没有直接交集，此处跳过。</p><p><del>需要的同学们可以拿这份笔记： <a href="https://sc-cos-1258290809.cos.ap-guangzhou.myqcloud.com/files/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1.pdf">概率论与数理统计(不完整版) - sunist</a></del></p><h2 id="5-选学-博弈论"><a href="#5-选学-博弈论" class="headerlink" title="5. (选学)博弈论"></a>5. (选学)博弈论</h2><p>博弈论，是经济学的一个分支，主要研究具有竞争或对抗性质的对象，在一定规则下产生的各种行为。博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。</p><p>通俗地讲，博弈论主要研究的是：在一个游戏中，进行游戏的多位玩家的策略。</p><p>下面是一个<code>Nim游戏</code>的示例：</p><p>$n$堆物品，每堆有$a_i$个，两个玩家轮流取走任意一堆的任意个物品，但不能不取。取走最后一个物品的人获胜。</p><blockquote><p>例如，如果现在有$3$堆物品，而每堆分别有$2,5,4$个，那么可以取走第$1$堆中的$2$个物品，局面就变成了$0,5,4$；或者也可以取走第$2$堆的$4$个物品，局面就变成了$2,1,4$。</p><p>如果现在的局面为$0,0,4$，甲取走了第$3$堆的$4$个物品，也就是取走了最后一个物品，此时甲获胜。</p></blockquote><p>如果将每个状态视为一个节点，再从每个状态向它的后继状态连边，我们就可以得到一个博弈状态图。如果节点$(i,j,k)$表示局面为$i,j,k$时的状态，则我们可以画出下面的博弈图(由于篇幅有限，故仅显示部分状态节点和部分边)：</p><center><div aligned="center"><img src="https://oi-wiki.org/math/images/game1.png"/></div></center><p>定义<code>必胜状态</code>为<code>先手必胜</code>的状态，<code>必败状态</code>为<code>先手必败</code>的状态。</p><p>通过推理，我们可以得出下面三条定理：</p><ul><li>定理 1：没有后继状态的状态是必败状态。</li><li>定理 2：一个状态是必胜状态当且仅当存在至少一个必败状态为它的后继状态。</li><li>定理 3：一个状态是必败状态当且仅当它的所有后继状态均为必胜状态.</li></ul><p>对于定理 1，如果游戏进行不下去了，那么这个玩家就输掉了游戏。</p><p>对于定理 2，如果该状态至少有一个后继状态为必败状态，那么玩家可以通过操作到该必败状态；此时对手的状态为必败状态——对手必定是失败的，而相反地，自己就获得了胜利。</p><p>对于定理 3，如果不存在一个后继状态为必败状态，那么无论如何，玩家只能操作到必胜状态；此时对手的状态为必胜状态——对手必定是胜利的，自己就输掉了游戏。</p><p>现在我们定义<code>Nim和</code>，记作$\operatorname{Nim}_S$：</p><script type="math/tex; mode=display">\operatorname{Nim}_S = a_1 \oplus a_2 \oplus \cdots \oplus a_n</script><p>则当且仅当$\operatorname{Nim}_S = 0$时，该状态为必败状态，否则为必胜状态。</p><p>该结论的证明过程可见<a href="https://oi-wiki.org/math/game-theory/#_3">Nim游戏 - 博弈论</a></p><p>为了计算这个$\operatorname{Nim}_S$，我们引入$\operatorname{mex}$函数与$\operatorname{SG}$函数：</p><script type="math/tex; mode=display">\operatorname{mex}(S)=\min\{x\} \quad (x \notin S, x \in N)</script><p>即$\operatorname{mex}$函数计算不属于集合$S$中的最小非负整数。</p><script type="math/tex; mode=display">\operatorname{SG}(x)=\operatorname{mex}\{\operatorname{SG}(y_1), \operatorname{SG}(y_2), \ldots, \operatorname{SG}(y_k)\}</script><p>对于由$n$个有向图游戏组成的组合游戏，设它们的起点分别为$s_1, s_2, \cdots , s_n$，则有定理：</p><p>当且仅当:</p><script type="math/tex; mode=display">\operatorname{SG}(s_1) \oplus \operatorname{SG}(s_2) \oplus \ldots \oplus \operatorname{SG}(s_n) \neq 0</script><p>这个游戏是先手必胜的。</p><p>我们就可以使用$\operatorname{SG}$函数与$\operatorname{Nim}_S$的结论来计算博弈论中的必胜问题了。</p><h2 id="6-进制转换"><a href="#6-进制转换" class="headerlink" title="6. 进制转换"></a>6. 进制转换</h2><p>讲过太多次，不想再讲了。</p>]]></content>
      
      
      <categories>
          
          <category> Courses </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Number-Theory </tag>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
