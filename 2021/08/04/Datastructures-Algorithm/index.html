

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://sc-cos-1258290809.cos.ap-guangzhou.myqcloud.com/oj/lab-logo-128.png">
  <link rel="icon" href="https://sc-cos-1258290809.cos.ap-guangzhou.myqcloud.com/oj/lab-logo-128.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="数据结构是本科期间的一门极其重要的课程，本文主要介绍了各种数据结构中的常用算法。">
  <meta name="author" content="Vector">
  <meta name="keywords" content="Computer Science">
  
  <title>数据结构算法 - SWU-ACM Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="//at.alicdn.com/t/font_2720498_cnvxe1sc8pl.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.swu-acm.cn","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"always","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Blog of Swu-Acm-Lab</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-website"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-index-archive-manage"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-daohangicon"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-circuit"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-f-about"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构算法">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      Vector
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-04 09:27" pubdate>
        2021年8月4日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      94
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构算法</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 天前
                
              </p>
            
            <div class="markdown-body">
              <p>数据结构是本科期间的一门极其重要的课程，本文主要介绍了各种数据结构中的常用算法。</p>
<span id="more"></span>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="一、生成树"><a href="#一、生成树" class="headerlink" title="一、生成树"></a>一、生成树</h3><p>兄贵，学习MST​之前先来了解一下什么是生成树吧，概念如下</p>
<blockquote>
<p>对于无向带权图G和一棵树T来说，如果T是G的子图，则称T为G的树，如果T是G的生成子图，则称T是G的生成树。</p>
<p>简而言之，生成树是一个极小连通子图，它含有图中全部顶点，但只有n-1条边。</p>
</blockquote>
<h3 id="二、最小生成树"><a href="#二、最小生成树" class="headerlink" title="二、最小生成树"></a>二、最小生成树</h3><p>最小生成树(Minimum cost Spanning Tree)，就是所有生成树中各边权值之和最小的那个生成树。</p>
<p><img src="https://z3.ax1x.com/2021/04/05/cMEOte.png" srcset="/img/loading.gif" lazyload alt="cMEOte.png"></p>
<blockquote>
<p><strong>构造最小生成树的准则</strong></p>
<ul>
<li>必须只使用该网络中的边来构造最小生成树；</li>
<li>必须使用且仅使用<em>n</em>-1条边来联结网络中的<em>n</em>个顶点；</li>
<li>不能使用产生回路的边。</li>
</ul>
</blockquote>
<p>对于最小生成树，常见的生成算法有两种：$Kruskal$算法和$Prim$算法，<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Eb41177d1?from=search&amp;seid=5353145092427265999">参考链接</a></p>
<h3 id="三、Kruskal算法"><a href="#三、Kruskal算法" class="headerlink" title="三、Kruskal算法"></a>三、Kruskal算法</h3><p><strong>定义</strong></p>
<p>此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。（贪心思想）</p>
<p><strong>具体步骤</strong></p>
<ol>
<li><p>把图中的所有边按代价从小到大排序； </p>
</li>
<li><p>把图中的$n$个顶点看成独立的$n$棵树组成的森林； </p>
</li>
<li><p>按权值从小到大选择边，所选的边连接的两个顶点$ui,vi$。$ui,vi$,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 </p>
</li>
<li><p>重复3,直到所有顶点都在一颗树内或者有$n-1$条边为止。</p>
</li>
</ol>
<p><strong>步骤演示</strong></p>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cMEXfH"><img src="https://z3.ax1x.com/2021/04/05/cMEXfH.png" srcset="/img/loading.gif" lazyload alt="cMEXfH.png"></a></p>
<h3 id="四、Prim算法"><a href="#四、Prim算法" class="headerlink" title="四、Prim算法"></a>四、Prim算法</h3><p><strong>定义</strong></p>
<p>此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点$s$开始，逐渐长大覆盖整个连通网的所有顶点。</p>
<p><strong>具体步骤</strong></p>
<ol>
<li><p>从任意一个顶点开始构造生成树，将该顶点加入生成树中，用一个一维数组selected来标记哪些顶点已经加入了生成树。</p>
</li>
<li><p>用数组$minDist$记录生成树到各个顶点的距离，最初生成树中之后1号 顶点，有直连边时，数组$minDist$中存储的就是1号顶点到该顶点的边的权值，没有直连边的时候就是INF，即初始化$minDist$数组。</p>
</li>
<li><p>从数组$minDist$中选出离生成树最近的顶点（假设这个顶点为j）加入到生成树中（即在数组$minDist$中找到最小值）。再以j为中间点，更新生成树到每一个非树顶点的距离（松弛）， 即如果$minDist[k]&gt;e[j][k]$则更新$minDist[k]=e[j][k]$。</p>
</li>
<li><p>重复第三步，直到生成树中有n个顶点为止。</p>
</li>
</ol>
<p><strong>步骤演示</strong></p>
<p><img src="https://z3.ax1x.com/2021/04/05/cMELkD.png" srcset="/img/loading.gif" lazyload alt="cMELkD.png"></p>
<h3 id="五、两种算法的比较"><a href="#五、两种算法的比较" class="headerlink" title="五、两种算法的比较"></a>五、两种算法的比较</h3><p><strong>从策略上来说</strong></p>
<p>Prim算法是直接查找，多次寻找邻边的权重最小值</p>
<p>Kruskal是需要先对权重排序后查找的</p>
<p><strong>从时间复杂度分析</strong></p>
<p>prim: 该算法的时间复杂度为$O(n2)$。 与图中边数无关，该算法适合于<strong>稠密图</strong></p>
<p>kruskal: 时间复杂度为$O(eloge)$。 适合<strong>稀疏图</strong></p>
<p><strong>所以说</strong></p>
<p>Kruskal在算法效率上是比Prim快的，因为Kruskal只需一次对权重的排序就能找到最小生成树；而Prim算法需要多次对邻边排序才能找到</p>
<h3 id="六、练习"><a href="#六、练习" class="headerlink" title="六、练习"></a>六、练习</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a></p>
<p><strong>Kruskal算法实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> gen[<span class="hljs-number">5005</span>],n,m,ans,cnt;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>    <span class="hljs-keyword">int</span> u;<span class="hljs-comment">//左边的点</span><br>    <span class="hljs-keyword">int</span> v;<span class="hljs-comment">//右边的点</span><br>    <span class="hljs-keyword">int</span> w;<span class="hljs-comment">//权值</span><br>&#125;edge[<span class="hljs-number">200005</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Edge a,Edge b)</span></span>&#123;<span class="hljs-comment">//排序方法</span><br>    <span class="hljs-keyword">return</span> a.w&lt;b.w;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(gen[x]==x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> gen[x]=<span class="hljs-built_in">find</span>(gen[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">kruskal</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(edge+<span class="hljs-number">1</span>,edge+m+<span class="hljs-number">1</span>,cmp);<span class="hljs-comment">//按照权值排序</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-keyword">int</span> eu=<span class="hljs-built_in">find</span>(edge[i].u);<span class="hljs-comment">//找到左边点和右边点的老大</span><br>        <span class="hljs-keyword">int</span> ev=<span class="hljs-built_in">find</span>(edge[i].v);<br>        <span class="hljs-keyword">if</span>(ev==eu)&#123;<span class="hljs-comment">//如果老大是一个，说明这俩在一个集合中，跳过</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<span class="hljs-comment">//否则</span><br>        ans+=edge[i].w;<span class="hljs-comment">//加上权值</span><br>        gen[ev]=eu;<span class="hljs-comment">//连接两个并查集</span><br>        cnt++;<br>        <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>)&#123;<span class="hljs-comment">//退出的条件</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        gen[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;edge[i].u&gt;&gt;edge[i].v&gt;&gt;edge[i].w;<br>    &#125;<br>    <span class="hljs-built_in">kruskal</span>();<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>Prim算法实现</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">200001</span>;<br><span class="hljs-keyword">bool</span> selected[maxn];<span class="hljs-comment">//是否被选中，初始为0</span><br><span class="hljs-keyword">int</span> minDist[maxn];<span class="hljs-comment">//最小值，初始为INF</span><br><span class="hljs-keyword">int</span> parent[maxn];<span class="hljs-comment">//存储最小值的那个边的父亲，初始为-1，代表不存在</span><br><span class="hljs-keyword">int</span> n,m,cnt,ans;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span><br>	<span class="hljs-keyword">int</span> begin;<br>	<span class="hljs-keyword">int</span> end;<br>	<span class="hljs-keyword">int</span> longth;<br>&#125;edge[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Prim</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>	cnt++;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-keyword">if</span>(edge[i].begin==x&amp;&amp;minDist[edge[i].end]&gt;edge[i].longth)&#123;<br>			minDist[edge[i].end]=edge[i].longth;<br>			parent[edge[i].end]=x;	<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(edge[i].end==x&amp;&amp;minDist[edge[i].begin]&gt;edge[i].longth)&#123;<br>			minDist[edge[i].begin]=edge[i].longth;<br>			parent[edge[i].begin]=x;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		cin&gt;&gt;edge[i].begin&gt;&gt;edge[i].end&gt;&gt;edge[i].longth;<br>	&#125;<br>	<span class="hljs-built_in">memset</span>(minDist,<span class="hljs-number">0x3f3f3f</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(minDist));<span class="hljs-comment">//minDist初始化</span><br>	selected[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<span class="hljs-comment">//先选择1加入最小生成树中</span><br>	<span class="hljs-built_in">Prim</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//遍历查找</span><br>	<span class="hljs-keyword">while</span>(cnt!=n)&#123;<span class="hljs-comment">//循环</span><br>		<span class="hljs-keyword">int</span> minn=<span class="hljs-number">0x3f3f3f</span>;<br>		<span class="hljs-keyword">int</span> chose=<span class="hljs-number">1</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>			<span class="hljs-keyword">if</span>(!selected[i]&amp;&amp;minDist[i]&lt;minn)&#123;<br>				minn=minDist[i];<br>				chose=i;<br>			&#125;<br>		&#125;<br>		selected[chose]=<span class="hljs-number">1</span>;<br>		ans+=minn;<br>		<span class="hljs-built_in">Prim</span>(chose);<br>	&#125;<br>	cout&lt;&lt;ans;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><blockquote>
<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。</p>
</blockquote>
<h3 id="二、应用情境"><a href="#二、应用情境" class="headerlink" title="二、应用情境"></a>二、应用情境</h3><ul>
<li>由于最小生成树需要维护连通性，并查集刚好可以做到通过构建树来判断元素之间的连通性、查找出两个元素是否位于同一元素。所以并查集在$MST$的建立过程中有着很大的作用</li>
<li>集合操作</li>
</ul>
<h3 id="三、操作"><a href="#三、操作" class="headerlink" title="三、操作"></a>三、操作</h3><p>在最开始的时候，每个元素都可以看做是一个单独的集合。我们在不断地进行查询和合并（并查集）请求操作中，元素之间进行合并。</p>
<p>一般都会用帮派来形容并查集的操作。每个集合都有一个帮主（人为设定），他统领着集合中的所有元素；在每一次帮派大战（合并），战败的集合便会被战胜的集合吞并，战胜集合的帮主成为合并帮主的新帮主，循环往复。</p>
<p>执行查询操作也很简单，只需要看他们的帮主是不是一个人即可~</p>
<p>1.<strong>初始化</strong></p>
<p>把每个点所在集合初始化为其自身。（自己是自己的帮主）</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    f[i]=i;	<span class="hljs-comment">//初始化</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>2.<strong>查找</strong></p>
<blockquote>
<p>查找元素所在的集合，即总帮主</p>
</blockquote>
<ul>
<li>普通做法（递归）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[k]==k) <span class="hljs-keyword">return</span> k;	<span class="hljs-comment">//如果自己是自己所在集合的帮主，那它就是总帮主</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(f[k]);		<span class="hljs-comment">//如果不是，就找他老大哥的老大哥</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>路径压缩</li>
</ul>
<p>上面这种做法很慢，所以我们可以直接在查找的过程中顺便把中间人士都指向总帮主</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>   <span class="hljs-keyword">if</span>(f[k]==k) <span class="hljs-keyword">return</span> k;	<span class="hljs-comment">//如果自己是自己所在集合的帮主，那它就是总帮主</span><br>    <span class="hljs-keyword">return</span> f[k]=<span class="hljs-built_in">find</span>(f[k]);		<span class="hljs-comment">//把图中的人的老大哥都变成总帮主</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>3.查询</strong></p>
<blockquote>
<p>查询两个元素是否在同一个集合中</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(p1)==<span class="hljs-built_in">find</span>(p2))&#123;	<span class="hljs-comment">//如果这俩隶属于同一个帮派</span><br>    cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>4.合并</strong></p>
<blockquote>
<p>把两个不相交的集合合并为一个集合</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">f[<span class="hljs-built_in">find</span>(a)]=<span class="hljs-built_in">find</span>(b);		<span class="hljs-comment">//让b和a的帮主变成一个人</span><br></code></pre></div></td></tr></table></figure>
<h3 id="四、练习"><a href="#四、练习" class="headerlink" title="四、练习"></a>四、练习</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3367">P3367 【模板】并查集</a></p>
<p><strong>AC代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">10005</span>;<br><span class="hljs-keyword">int</span> n,m,f[maxn];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(f[k]==k) <span class="hljs-keyword">return</span> k;<span class="hljs-comment">//如果自己的老大就是自己，那它就是总老大</span><br>    <span class="hljs-keyword">return</span> f[k]=<span class="hljs-built_in">find</span>(f[k]);<span class="hljs-comment">//使途中经过的人的大哥也变成老大</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        f[i]=i;<span class="hljs-comment">//初始化i的老大为自己</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>,p1,p2,p3;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;p1&gt;&gt;p2&gt;&gt;p3;<br>        <span class="hljs-keyword">if</span>(p1==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//如果是执行合并操作</span><br>            f[<span class="hljs-built_in">find</span>(p2)]=<span class="hljs-built_in">find</span>(p3);<span class="hljs-comment">//让p2的老大变成p3的老大</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//查询操作</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(p2)==<span class="hljs-built_in">find</span>(p3))&#123;<span class="hljs-comment">//如果p2的老大和p3的老大是一个人</span><br>                cout&lt;&lt;<span class="hljs-string">&quot;Y&quot;</span>&lt;&lt;endl;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cout&lt;&lt;<span class="hljs-string">&quot;N&quot;</span>&lt;&lt;endl;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>在学习拓扑排序之前，我们先来了解什么事AOV网。</p>
<h3 id="一、AOV网"><a href="#一、AOV网" class="headerlink" title="一、AOV网"></a>一、AOV网</h3><blockquote>
<ul>
<li>用顶点表示活动，用弧表示活动间优先关系的<strong>有向图</strong>称为顶点表示活动的网(Activity On Vertex network)，简称AOV网。</li>
<li>在网中，若从顶点$i$到顶点$j$有一条有向路径，则$i$是$j$的前驱，$j$是$i$的后继。若$<v_i,v_j>$是图中有向边，则$v_i$是$v_j$的直接前驱；$v_j$是$v_i$的直接后继。</li>
<li><strong>AOV网中不允许有回路</strong>，这意味着某项活动以自己为先决条件。</li>
<li><strong>对于给定的AOV网应首先判定网中是否存在环</strong>。检测的办法是对有向图构造其顶点的<strong>拓扑有序序列</strong>，若网中所有顶点都在它的拓扑有序序列中，则该AOV网必定不存在环。<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/cMtvOf"><img src="https://z3.ax1x.com/2021/04/05/cMtvOf.png" srcset="/img/loading.gif" lazyload alt="AOV.png"></a></li>
</ul>
</blockquote>
<p>拓扑排序就是在AOV的基础上进行的。</p>
<h3 id="二、AOE网"><a href="#二、AOE网" class="headerlink" title="二、AOE网"></a>二、AOE网</h3><blockquote>
<p>AOE网(Activity On Edge)：也叫边表示活动的网。AOE网是一个带权的有向无环图，其中顶点表示事件，弧表示活动，权表示活动持续时间</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>拓扑排序(Topological Sort) 是由某个集合上的一个偏序得到该集合上的一个全序，这个操作就称之为拓扑排序。</p>
</blockquote>
<p>例如，一个软件专业的学生必须学习一系列基本课程，其中有些课是基础课，它独立于其它课程，如《高等数学》；而另一些课程必须在学完作为它的基础的先修课程才能开始。如在《程序设计基础》和《离散数学》学完之前就不能开始学习《数据结构》。</p>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><blockquote>
<ul>
<li>选择一个入度为 0 的顶点并输出。</li>
<li>从 AOV 网中删除此顶点及以此顶点为起点的所有关联边。</li>
<li>重复上述两步，直到不存在入度为 0 的顶点为止。</li>
<li>若输出的顶点数小于 AOV 网中的顶点数，则说明 AOV 网中回路，不是一个标准的 AOV 网。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://imgtu.com/i/cMtbYd"><img src="https://z3.ax1x.com/2021/04/05/cMtbYd.png" srcset="/img/loading.gif" lazyload alt="cMtbYd.png"></a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ut41197TE?from=search&amp;seid=17211423774363355925">更加具体的过程请参考</a></p>
<h4 id="题目练习"><a href="#题目练习" class="headerlink" title="题目练习"></a>题目练习</h4><p>接下来我们来练习一道有关拓扑排序的<a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=1285">题目</a>。</p>
<blockquote>
<p>这道题是一道简单的拓扑排序，题中已经给出了<code>具体的提示</code>(其他说明：符合条件的排名可能不是唯一的，<code>此时要求输出时编号小的队伍在前</code>；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名)。<br>正是练习拓扑排序的好机会。</p>
</blockquote>
<p><strong>AC代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn=<span class="hljs-number">1000</span>;<br>vector&lt;<span class="hljs-keyword">int</span>&gt;vec[maxn]; <span class="hljs-comment">// 邻接表建图。</span><br><span class="hljs-keyword">int</span> du[maxn];<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">topsort</span><span class="hljs-params">()</span></span>&#123;<br>	priority_queue&lt;<span class="hljs-keyword">int</span>,vector&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt; &gt; s;<span class="hljs-comment">//使用优先队列，来保证输出时编号小的队伍在前</span><br>	<span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>	&#123;<br>		<span class="hljs-keyword">if</span>(!du[i])<span class="hljs-comment">//将入度为0的节点入队</span><br>			s.<span class="hljs-built_in">push</span>(i);<br>	&#125;<br>	<span class="hljs-keyword">while</span>(!s.<span class="hljs-built_in">empty</span>())<br>	&#123;<br>		<span class="hljs-keyword">int</span> now=s.<span class="hljs-built_in">top</span>();<br>       	  s.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)<br>		&#123;<br>			cout&lt;&lt;now;<br>			flag=<span class="hljs-number">1</span>;<br>		&#125;<br>		<span class="hljs-keyword">else</span><br>			cout&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;now; <span class="hljs-comment">// 最后一名没有空格</span><br>		<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vec[now].<span class="hljs-built_in">size</span>();i++) <span class="hljs-comment">//除去与该节点相关的节点的关联边。</span><br>		&#123;<br>			<span class="hljs-keyword">if</span>(--du[vec[now][i]]==<span class="hljs-number">0</span>)	<br>				s.<span class="hljs-built_in">push</span>(vec[now][i]);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)<br>	&#123;<br>		<span class="hljs-built_in">memset</span>(du,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(du));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>			vec[i].<span class="hljs-built_in">clear</span>();<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>		&#123;<br>			<span class="hljs-keyword">int</span> a,b;<br>			cin&gt;&gt;a&gt;&gt;b;<br>			vec[a].<span class="hljs-built_in">push_back</span>(b);<br>			du[b]++;<br>		&#125;<br>		<span class="hljs-built_in">topsort</span>();<br>		cout&lt;&lt;endl;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;	<br>&#125; <br></code></pre></div></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=3342">如果有兴趣可以试试做下这道题，判断图中是否有环</a></p>
<h2 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h2><h3 id="一、定义-1"><a href="#一、定义-1" class="headerlink" title="一、定义"></a>一、定义</h3><blockquote>
<p>如果从图中某一顶点(称为源点)到达另一顶点(称为终点)的路径可能不止一条，如何找到一条路径，使得沿此路径各边上的权值总和达到最小。</p>
</blockquote>
<p>解决这个问题，我们有两种算法：Dijkstra算法 和 Floyd算法。</p>
<h3 id="二、Dijkstra算法"><a href="#二、Dijkstra算法" class="headerlink" title="二、Dijkstra算法"></a>二、Dijkstra算法</h3><p>Dijkstra算法是单源最短路径，也就是说一个点到其他所有点的最短路径。<br><strong>它的主要思想就是根据已经确定了的点的距离，来确定该点相邻顶点的距离，不断的向外散射，直到所以的点的到起点的最短距离确定为止。</strong>  </p>
<h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><blockquote>
<ul>
<li>把图中所有顶点分成两组，第一组包括已确定最短路径的顶点，第二组包括尚未确定最短路径的顶点，按最短路径长度递增的顺序逐个把第二组的顶点加到第一组中去，直至从$v_0$出发可以到达的所有顶点都包括到第一组中。</li>
<li>在这过程中，总保持从$v_0$到第一组各顶点的最短路径长度都不大于从$v_0$到第二组的任何顶点的最短路径长度。<h4 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h4></li>
<li>一开始第一组只包括顶点$v_0$，第二组包括其他所有的顶点，$v_0$对应的距离为0。</li>
<li>第二组的顶点对应的距离是这样确定的：若图中有边$<v_0，v_i>$， vi的距离为此边所带的权值，否则$v_i$的距离为一个很大的数（大于所有顶点间的路径长度）。</li>
<li>然后每次从第二组的顶点中选一个其距离值为最小的$v_m$加入到第一组中。</li>
<li>每往第一组加入一个顶点$v_m$ ，就要对第二组中的各个顶点的距离值进行一次修正。若加进$V_m$做中间顶点使从$v_0$到$v_j$的最短路径比不加$v_m$的路径为短，则要修改$v_j$的距离值。修改后再选距离值最小的顶点加入到第一组中。</li>
<li>重复3和4步骤直至所有点都在第一组中。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1q4411M7r9?from=search&amp;seid=4117483000935554948">动画演示</a></p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><blockquote>
<p>$O(n^2)$</p>
<h4 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span>   <span class="hljs-comment">//s是起点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(visit, <span class="hljs-literal">false</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(visit));    <br>	visit[s] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//将s加入第一组集合</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>		<span class="hljs-comment">//dist[i] 代表着s带i点的距离</span><br>        dist[i] = graph[s][i];<span class="hljs-comment">//对graph进行了处理，初始化矩阵全部初始化为无穷大。</span><br>    &#125;<br>     <br>    <span class="hljs-keyword">int</span> index;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)&#123;<span class="hljs-comment">// 求出s到n-1个点的最短路径。</span><br>        <span class="hljs-keyword">int</span> mincost = INF;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//找出最小值那个点</span><br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; dist[j] &lt; mincost)&#123;<br>                mincost = dist[j];<br>                index = j;    <br>            &#125;    <br>        &#125;<br>        visit[index] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//把这个点加入第一组</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<span class="hljs-comment">//更新距离</span><br>            <span class="hljs-keyword">if</span>(!visit[j] &amp;&amp; dist[j] &gt; dist[index] + graph[index][j])&#123;<br>                dist[j] = dist[index] + graph[index][j];<br>            &#125;    <br>        &#125;    <br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="题目练习-1"><a href="#题目练习-1" class="headerlink" title="题目练习"></a>题目练习</h4><p><a target="_blank" rel="noopener" href="http://acm.hdu.edu.cn/showproblem.php?pid=2544">一道模板题</a><br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inf 0x3f3f3f</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> g[<span class="hljs-number">200</span>][<span class="hljs-number">200</span>];<br><span class="hljs-keyword">int</span> d[<span class="hljs-number">200</span>]; <br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">200</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span>&#123;<br>	<span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(vis));<br>	vis[s] = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		d[i] = g[s][i];<br>	&#125;<br>	<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">int</span> mincost = inf;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;mincost)&#123;<br>				k = j;<br>				mincost = d[j];<br>			&#125;<br>		&#125;<br>		vis[k] = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>			<span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&gt;d[k]+g[k][j])&#123;<br>				d[j] = d[k]+g[k][j];<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(cin&gt;&gt;n&gt;&gt;m)&#123;<br>		<span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span> &amp;&amp; m==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>		<span class="hljs-built_in">memset</span>(g,inf,<span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(g));<br>		<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<span class="hljs-comment">//建图 </span><br>			<span class="hljs-keyword">int</span> a,b,c;<br>			cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>			g[a][b]=g[b][a]=c;<span class="hljs-comment">//无向图</span><br>		&#125;<br>		<span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//从起点1出发</span><br>		cout&lt;&lt;d[n]&lt;&lt;endl;<br>	&#125;<br>&#125;<br><span class="hljs-comment">//还有一些题需要输出路径，这时只需要加一个path[][]数组即可。</span><br></code></pre></div></td></tr></table></figure></p>
<h3 id="三、Floyd算法"><a href="#三、Floyd算法" class="headerlink" title="三、Floyd算法"></a>三、Floyd算法</h3><p>Floyd算法是每一对顶点之间的最短路径。在此有两种解决方法：每次以一个顶点为源点，重复执行Dijkstra算法n次 和 弗洛伊德(Floyd)算法。</p>
<h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>逐个顶点试探</p>
<ul>
<li>初始时设置一个$n$阶方阵，令其对角线元素为$0$，若存在弧$<vi,vj>$，则对应元素为权值；否则为$\infty$。</li>
<li>逐步试着在原直接路径中增加中间顶点，若加入中间点后路径变短，则修改之；否则，维持原值。</li>
<li>所有顶点试探完毕，算法结束。</li>
</ul>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1LE411R7CS?from=search&amp;seid=4295088178287909313">详细过程</a></p>
<h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Floyd算法的时间复杂度和重复执行Dijkstra算法n次的时间复杂度相同都是$O(n^3)$。但是Floyd的形式更加简单。</p>
<h4 id="核心代码-1"><a href="#核心代码-1" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; k ++)&#123; <span class="hljs-comment">//作为循环中间点的k必须放在最外一层循环 </span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++)&#123;<br>                <span class="hljs-keyword">if</span>(dist[i][j] &gt; dist[i][k] + dist[k][j])&#123;<br>                    dist[i][j] = dist[i][k] + dist[k][j];    <span class="hljs-comment">//dist[i][j]得出的是i到j的最短路径 </span><br>                &#125;     <br>            &#125;    <br>        &#125;    <br>    &#125;    <br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><p>在了解下列算法之前我们介绍一些概念性问题。</p>
<blockquote>
<ul>
<li>有向图G中，以顶点v为起点的弧的数目称为v的出度，记做$deg+ （v）$；以顶点v为终点的弧的数目称为v的入度，记做$deg-（v）$。</li>
<li>如果在有向图G中，有一条$<u，v>$向道路，则$v$称为$u$可达的，或者说，从$u$可达$v$。</li>
<li>如果有向图$G$的<strong>任意两个顶点</strong>都<strong>互相</strong>可达，则称图$G$是强连通图，如果有向图G存在两顶点$u$和$v$使得$u$不能到$v$，或者$v$不能到$u$，则称图$G$是强非连通图。</li>
<li>如果有向图$G$不是强连通图，他的子图$G2$是强连通图，点$v$属于$G2$，任意包含$v$强连通子图也是$G2$的子图，则称$G2$是有向图G的极大强连通子图，也称<strong>强连通分量</strong>(是对于极大连通子图来说的)。</li>
<li><strong>强连通</strong>其实就是指图中有两点$u，v$。使得能够找到有向路径从$u$到$v$并且也能够找到有向路径从$v$到$u$，则称$u$，$v$是强连通的。</li>
</ul>
</blockquote>
<p>我们来通过下图来加强对这些概念的理解<br><a target="_blank" rel="noopener" href="https://imgtu.com/i/cl77qI"><img src="https://z3.ax1x.com/2021/04/06/cl77qI.png" srcset="/img/loading.gif" lazyload alt="cl77qI.png"></a><br>{1,2,3,4}为一个强连通分量,<strong>{5},{6}也分别是两个强连通分量</strong>。</p>
<p>那我们该如何求得强连通分量呢？下我们学习三个算法：$Tarjan$算法、<br>$Kosaraju$算法 和 $Gabow$算法。</p>
<h3 id="一、-Tarjan-算法"><a href="#一、-Tarjan-算法" class="headerlink" title="一、$Tarjan$算法"></a>一、$Tarjan$算法</h3><p>Tarjan的主要思想就是采用<code>dfs</code>的回溯来找到比他更早的时间点来确定他们是否为同一强连通分量。那么这点中一定有环，我们就可以利用这个环来判断强连通分量。<br>那么具体操作是什么呢?</p>
<h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><ol>
<li>我们先定义两个数组$dfn[]$ 和 $low[]$，其中$dfn[u]$代表搜索到$u$时的次数编号，$low[u]$为$u$或者$u$的子树能够追寻的最小编号。</li>
<li>初始化$low[u] = dfn[u]$.</li>
<li>一直遍历到没有其他点可以走或者已经走过的点，维护$low[]$。 $low[u] = min (low[u],low[v])$其中$v$是$u$指向且<code>还在栈中</code>的点。</li>
<li>判断$dfn[u] == low[u]$，若成立，则找到了一个强连通量。最后出栈。这里为什么呢?因为点$u$先进栈，那么dfs到最后一个点时，那么这个点指向之前入栈的点，那么它的$low[u]$肯定是较小的，所以更新为low的值为$u$的low，以此慢慢回溯得到的就是$dfn[u] == low[u]$。因为有环的存在，那么一定会有一个点指向起始点，那么这个点更新后他的low就是这个连通分量中最小的，所以一路回溯下去，最终就会的得到$dfn[u] == low[u]$。</li>
<li>以此重复循环以上步骤就可以得出有多少个连通分量和那些点事同一个连通分量。</li>
<li>下面我将以上图中{1,2,3,4}连通量中的1节点开始举例。这里为了方便不考虑5，6节点。<blockquote>
<ul>
<li>$low[1] = dfn[1] = 1$</li>
<li>$low[3] = dfn[3] = 2$</li>
<li>$low[4] = dfn[4] = 3$</li>
<li>$low[4] = min(low[4],low[1]) = 1$</li>
<li>$low[3] = min(low[3],low[4]) = 1$</li>
<li>$low[2] = dfn[2] = 4$</li>
<li>$low[2] = min(low[2],low[4]) = 1$</li>
<li>$low[1] = min(low[2],low[1] = 1)$</li>
<li>$low[1] = dfn[1] = 1$<br>即找到了一个连通分量。</li>
</ul>
</blockquote>
</li>
</ol>
<p>这里可能表示不清楚或者有错误，具体可以参考下<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV19J411J7AZ?from=search&amp;seid=15425029704146605635">这个视频</a><br><strong>经过测试，一个连通的dfn不一定全部相同</strong></p>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>邻接表：$O(V+E)$<br>邻接矩阵：$O(V^2)$</p>
<h4 id="核心代码-2"><a href="#核心代码-2" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>	instack[u] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//u是否在栈中</span><br>	stack[top] = u;<span class="hljs-comment">//入栈</span><br>	low[u] = dfn[u] = ++cnt;<span class="hljs-comment">//初始化</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;vec[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		<span class="hljs-keyword">int</span> v = vec[u][i];<span class="hljs-comment">//下一个节点</span><br>		<span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfn</span>(v))&#123;<br>			<span class="hljs-built_in">tarjan</span>(v);<br>			<span class="hljs-comment">//回溯时更新</span><br>			low[u] = <span class="hljs-built_in">min</span>(low[u],low[v]);<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">instack</span>(v))&#123;<span class="hljs-comment">//这个点还在栈中（这尤为重要，若要一个点个指向一个强连通分量，没有这句话，那么low将会变小）</span><br>			<span class="hljs-comment">/*访问到根节点，或者其他情况.这里需要注意一下。强连通图中可以用low[u] = min(low[u],low[v]);但是在割点这种问题就必须要下面这种格式。推荐使用这种*/</span><br>			low[u] = <span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">int</span> j;<br>	<span class="hljs-keyword">if</span>(low[u] == dfn[u])&#123;<span class="hljs-comment">//判断</span><br>		ans++;<br>		<span class="hljs-keyword">do</span>&#123;<br>			j=stack[top--];<br>			instack[j] = <span class="hljs-literal">false</span>;<br>			Belong[j] = ans;<span class="hljs-comment">//染色，也就是哪一些是连通块。</span><br>		&#125;<span class="hljs-keyword">while</span>(j!=u)<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="题目练习-2"><a href="#题目练习-2" class="headerlink" title="题目练习"></a>题目练习</h4><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2863">题链接</a><br>纯模板题<br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> index;<span class="hljs-comment">//序数</span><br><span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//答案</span><br><span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">bool</span> instack[<span class="hljs-number">100010</span>];<span class="hljs-comment">//记录这个节点是否在栈中</span><br><span class="hljs-keyword">int</span> stack[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> dfn[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> low[<span class="hljs-number">100010</span>];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; M[<span class="hljs-number">100010</span>];<span class="hljs-comment">//图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">int</span> v;<br>	low[u] = dfn[u] = ++index;<br>	stack[++top] = u;<br>	instack[u] = <span class="hljs-literal">true</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		v = M[u][i];<br>		<span class="hljs-keyword">if</span>(!dfn[v])&#123;<br>			<span class="hljs-built_in">tarjan</span>(v);<br>			low[u] = <span class="hljs-built_in">min</span>(low[u],low[v]);<br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(instack[v])&#123;<br>			low[u] = <span class="hljs-built_in">min</span>(low[u],dfn[v]);<br>		&#125; <br>	&#125;<br>	<span class="hljs-keyword">if</span>(dfn[u] == low[u])&#123;<br>		<span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">do</span>&#123;<br>			v = stack[top--];<span class="hljs-comment">//出栈</span><br>			x++;<br>			instack[v] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//出栈</span><br>		&#125;<span class="hljs-keyword">while</span>(u!=v);<br>		<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ans++;<span class="hljs-comment">//如果这个强连通分量里面的节点数大于1</span><br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-keyword">int</span> x,y;<br>		cin&gt;&gt;x&gt;&gt;y;<br>		M[x].<span class="hljs-built_in">push_back</span>(y);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(!dfn[i])&#123;<span class="hljs-comment">//若没有被访问过 </span><br>			<span class="hljs-built_in">tarjan</span>(i);<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;ans;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h3 id="二、Kosaraju算法"><a href="#二、Kosaraju算法" class="headerlink" title="二、Kosaraju算法"></a>二、Kosaraju算法</h3><p>kosaraju算法进行两次dfs，第一次在原图上进行，并在结点递归调用返回时将结点压入一个栈中，第二次dfs在原图的反图上进行，并且初始点选择栈中最上面的点，每次dfs所访问的点构成一个强连通分量。</p>
<h4 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h4><blockquote>
<ul>
<li>返图与原图的强连通分量相同</li>
<li>若原图从分量I能走到分量II，则反图不能从分量I走到分量II</li>
</ul>
</blockquote>
<p>此算法的核心在于对于各个强连通分量进行了分离，也就是说，各个强连通分量之间无法到达。<br>那么这是如何实现的呢？</p>
<blockquote>
<ul>
<li>我们把这些强连通分量缩点（也就是是说一个强连通分量看为一个点），这样我们就得到了一个有向无环图（DAG）。</li>
<li>我先对这个有向无环图进图DFS遍历，那么先遍历的那个缩点是这次（可能会有多次）遍历序列的根，那么这个缩点可以达到其他的强连通分量。子树也是如此</li>
<li>那么第二次对原图取反，对于这个根缩点就是第一个访问的，那么对他来说就没有进入的边，那么再对它进行遍历那么得到的一定就是一个强连通分量。</li>
<li>接下来在对栈里的其他点进行遍历的时候也不会连通到这个点，因为它已经被标记了。<h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4></li>
<li>对原图进行DFS，记录定点的后序遍历序列（入栈）</li>
<li>选出栈顶的顶点，对反图进行DFS，标记出能够遍历到的顶点，这些顶点就构成了一个强连通分量。</li>
<li>如果还有顶点没有被标记，重复过程2直至结束。<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4>邻接表：$O(V+E)$<br>邻接矩阵：$O(V^2)$<br>但是tarjan的效率比Kosaraju高30%.<h4 id="核心代码-3"><a href="#核心代码-3" class="headerlink" title="核心代码"></a>核心代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M1[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		<span class="hljs-keyword">int</span> next = M1[u][i];<br>		<span class="hljs-keyword">if</span>(!v1[next])&#123;<br>			v1[next] = <span class="hljs-literal">true</span>;<br>			<span class="hljs-built_in">dfs1</span>(next);<br>		&#125;<br>	&#125;<br>	stack[++top] = u;<span class="hljs-comment">//后序入栈 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<span class="hljs-comment">//对反图进行dfs </span><br>	belongs[u] = j;<span class="hljs-comment">//染色，把同一强连通分量的点统一标记</span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M2[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		<span class="hljs-keyword">int</span> next = M2[u][i];<br>		<span class="hljs-keyword">if</span>(!v2[next])&#123;<br>			v2[next] = <span class="hljs-literal">true</span>;<br>			<span class="hljs-built_in">dfs2</span>(next);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</blockquote>
<h4 id="题目练习-3"><a href="#题目练习-3" class="headerlink" title="题目练习"></a>题目练习</h4><p>还是Tarjan的<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2863">练习题</a><br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//答案</span><br><span class="hljs-keyword">int</span> top;<span class="hljs-comment">//栈顶</span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> x;<span class="hljs-comment">//记录该强连通节点的个数 </span><br><span class="hljs-keyword">bool</span> v1[<span class="hljs-number">100010</span>];<span class="hljs-comment">//第一遍历的标记 </span><br><span class="hljs-keyword">bool</span> v2[<span class="hljs-number">100010</span>]; <span class="hljs-comment">//第二次遍历的标记 </span><br><span class="hljs-keyword">int</span> stack[<span class="hljs-number">100010</span>];<span class="hljs-comment">//栈 </span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; M1[<span class="hljs-number">100010</span>];<span class="hljs-comment">//图</span><br>vector&lt;<span class="hljs-keyword">int</span>&gt; M2[<span class="hljs-number">100010</span>];<span class="hljs-comment">//反图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M1[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		<span class="hljs-keyword">int</span> next = M1[u][i];<br>		<span class="hljs-keyword">if</span>(!v1[next])&#123;<br>			v1[next] = <span class="hljs-literal">true</span>;<br>			<span class="hljs-built_in">dfs1</span>(next);<br>		&#125;<br>	&#125;<br>	stack[++top] = u;<span class="hljs-comment">//后序入栈 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<span class="hljs-comment">//对反图进行dfs </span><br>	x++;<span class="hljs-comment">//记录 </span><br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M2[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		<span class="hljs-keyword">int</span> next = M2[u][i];<br>		<span class="hljs-keyword">if</span>(!v2[next])&#123;<br>			v2[next] = <span class="hljs-literal">true</span>;<br>			<span class="hljs-built_in">dfs2</span>(next);<br>		&#125;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-keyword">int</span> x,y;<br>		cin&gt;&gt;x&gt;&gt;y;<br>		M1[x].<span class="hljs-built_in">push_back</span>(y);<br>		M2[y].<span class="hljs-built_in">push_back</span>(x);<span class="hljs-comment">//返图 </span><br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(!v1[i])&#123;<span class="hljs-comment">//若没有被访问过 </span><br>			v1[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>			<span class="hljs-built_in">dfs1</span>(i);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">while</span>(top)&#123;<br>		<span class="hljs-keyword">int</span> v = stack[top--];<span class="hljs-comment">//出栈</span><br>		x = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">if</span>(!v2[v])&#123;<br>			v2[v] = <span class="hljs-literal">true</span>;<br>			<span class="hljs-built_in">dfs2</span>(v);<br>		&#125; <br>		<span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">1</span>) ans++;<br>	&#125; <br>	cout&lt;&lt;ans;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>
<h3 id="三、-Gabow-算法"><a href="#三、-Gabow-算法" class="headerlink" title="三、$Gabow$算法"></a>三、$Gabow$算法</h3><p>Gabow算法的思想与Tarjan一致。<br>该算法使用了两个栈，一个顶点栈，另外一个栈的功能类似于Tarjan算法中的数组low。从起始顶点u处开始进行DFS过程中，当一条回路显示这组顶点都属于同一个强连通分支时，就会弹出栈二中顶点，只留下回边的目的顶点，也即搜索的起点u。</p>
<p>当回溯到递归起始顶点u时，如果此时该顶点在栈二顶部，则说明该顶点是一个强联通分量的起始顶点，那么在该顶点之后搜索的顶点都属于同一个强连通分支。于是，从第一个栈中弹出这些点，形成一个强连通分支。</p>
<h3 id="题目练习-4"><a href="#题目练习-4" class="headerlink" title="题目练习"></a>题目练习</h3><p>还是Tarjan的<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2863">练习题</a><br><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> ans;<span class="hljs-comment">//答案</span><br><span class="hljs-keyword">int</span> t1;<span class="hljs-comment">//栈顶</span><br><span class="hljs-keyword">int</span> t2;<span class="hljs-comment">//栈顶 </span><br><span class="hljs-keyword">int</span> n,m;<br><span class="hljs-keyword">int</span> index;<br><span class="hljs-keyword">int</span> x;<span class="hljs-comment">//记录该强连通节点的个数 </span><br><span class="hljs-keyword">int</span> dfn[<span class="hljs-number">100010</span>];<br><span class="hljs-keyword">int</span> stack_2[<span class="hljs-number">100010</span>]; <br><span class="hljs-keyword">int</span> stack_1[<span class="hljs-number">100010</span>];<span class="hljs-comment">//栈 </span><br><span class="hljs-keyword">int</span> instack[<span class="hljs-number">100010</span>];<br>vector&lt;<span class="hljs-keyword">int</span>&gt; M[<span class="hljs-number">100010</span>];<span class="hljs-comment">//图</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Gabow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span></span>&#123;<br>	dfn[u] = ++index;<br>	stack_1[++t1] = stack_2[++t2] = u;<br>	instack[u] = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;M[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>		<span class="hljs-keyword">int</span> v = M[u][i];<br>		<span class="hljs-keyword">if</span>(!dfn[v])&#123;<br>			<span class="hljs-built_in">Gabow</span>(v);<br>			<span class="hljs-comment">//while(dfn[stack_2[t2]]&gt;dfn[v]) t2--; 这里加不加好像都可以</span><br>		&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(instack[v])&#123;<br>			<span class="hljs-keyword">while</span>(dfn[stack_2[t2]]&gt;dfn[v]) t2--;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">if</span>(u==stack_2[t2])&#123;<br>		<span class="hljs-keyword">int</span> j;<br>		<span class="hljs-keyword">do</span>&#123;<br>			j = stack_1[t1--];<br>			x++;<br>			instack[j] = <span class="hljs-number">0</span>;<br>		&#125;<span class="hljs-keyword">while</span>(u!=j);<br>	&#125;<br>	<span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) ans++;<br>&#125; <br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>	cin&gt;&gt;n&gt;&gt;m;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>		<span class="hljs-keyword">int</span> x,y;<br>		cin&gt;&gt;x&gt;&gt;y;<br>		M[x].<span class="hljs-built_in">push_back</span>(y);<br>	&#125;<br>	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>		<span class="hljs-keyword">if</span>(!dfn[i])&#123;<span class="hljs-comment">//若没有被访问过 </span><br>			x = <span class="hljs-number">0</span>;<br>			<span class="hljs-built_in">Gabow</span>(i);<br>		&#125;<br>	&#125;<br>	cout&lt;&lt;ans;<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Courses/">Courses</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C/">C++</a>
                    
                      <a class="hover-with-bg" href="/tags/STL/">STL</a>
                    
                      <a class="hover-with-bg" href="/tags/Datastructures/">Datastructures</a>
                    
                      <a class="hover-with-bg" href="/tags/Algorithm/">Algorithm</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/08/04/Guidance/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">写作指导</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/04/CXX-STL/">
                        <span class="hidden-mobile">C++标准模版库</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"Ru1edutq5JbFc8uUYOqE9TIG-gzGzoHsz","appKey":"KCKGmFcStA3gCXHYVwGprLs3","placeholder":"System.Console.Wrintline(骚话)","path":"window.location.pathname","avatar":"retro","meta":["nick","mail"],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":true,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":true,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     Copyright (C) Southwest University ACM Laboratory, 2019-2021 </br> 西南大学ACM实验室版权所有 </br> <!--a href="https://gitee.com/SWU-ACM-Lab"><i class="iconfont icon-gitee-fill"></i></a--> <a target="_blank" rel="noopener" href="https://github.com/SWU-ACM-Lab"><i class="iconfont icon-github-fill"></i></a>    <a target="_blank" rel="noopener" href="https://space.bilibili.com/1599858052"><i class="iconfont icon-bilibili-fill"></i></a> <a href="https://blog.swu-acm.cn"><i class="iconfont icon-hexo"></i></a> <a target="_blank" rel="noopener" href="http://n4j-s.swu-acm.cn"><i class="iconfont icon-neoj"></i></a> <a target="_blank" rel="noopener" href="https://auth.swu-acm.cn"><i class="iconfont icon-icon_authority"></i></a> <a target="_blank" rel="noopener" href="https://gitea.swu-acm.cn/SWU-ACM-Lab"><i class="iconfont icon-gitea"></i></a> <a target="_blank" rel="noopener" href="https://mail.swu-acm.cn"><i class="iconfont icon-outlook"></i></a> </br> <a target="_blank" rel="noopener" href="https://www.swu-acm.cn">前往主站</a> | <a target="_blank" rel="noopener" href="https://oj.swu-acm.cn">测评平台</a> | <a target="_blank" rel="noopener" href="https://files.swu-acm.cn">在线网盘</a> | <a target="_blank" rel="noopener" href="https://mirrors.swu-acm.cn">开源镜像</a> | <a target="_blank" rel="noopener" href="https://swu-acm.jetbrains.space">协作空间</a> </br> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/static/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.10.1/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>







<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
